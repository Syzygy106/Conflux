{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IFunctionsRouter} from \"./interfaces/IFunctionsRouter.sol\";\nimport {IFunctionsClient} from \"./interfaces/IFunctionsClient.sol\";\n\nimport {FunctionsRequest} from \"./libraries/FunctionsRequest.sol\";\n\n/// @title The Chainlink Functions client contract\n/// @notice Contract developers can inherit this contract in order to make Chainlink Functions requests\nabstract contract FunctionsClient is IFunctionsClient {\n  using FunctionsRequest for FunctionsRequest.Request;\n\n  IFunctionsRouter internal immutable i_router;\n\n  event RequestSent(bytes32 indexed id);\n  event RequestFulfilled(bytes32 indexed id);\n\n  error OnlyRouterCanFulfill();\n\n  constructor(address router) {\n    i_router = IFunctionsRouter(router);\n  }\n\n  /// @notice Sends a Chainlink Functions request\n  /// @param data The CBOR encoded bytes data for a Functions request\n  /// @param subscriptionId The subscription ID that will be charged to service the request\n  /// @param callbackGasLimit the amount of gas that will be available for the fulfillment callback\n  /// @return requestId The generated request ID for this request\n  function _sendRequest(\n    bytes memory data,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) internal returns (bytes32) {\n    bytes32 requestId = i_router.sendRequest(\n      subscriptionId,\n      data,\n      FunctionsRequest.REQUEST_DATA_VERSION,\n      callbackGasLimit,\n      donId\n    );\n    emit RequestSent(requestId);\n    return requestId;\n  }\n\n  /// @notice User defined function to handle a response from the DON\n  /// @param requestId The request ID, returned by sendRequest()\n  /// @param response Aggregated response from the execution of the user's source code\n  /// @param err Aggregated error from the execution of the user code or from the execution pipeline\n  /// @dev Either response or error parameter will be set, but never both\n  function fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal virtual;\n\n  /// @inheritdoc IFunctionsClient\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external override {\n    if (msg.sender != address(i_router)) {\n      revert OnlyRouterCanFulfill();\n    }\n    fulfillRequest(requestId, response, err);\n    emit RequestFulfilled(requestId);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/interfaces/IFunctionsClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Chainlink Functions client interface.\ninterface IFunctionsClient {\n  /// @notice Chainlink Functions response handler called by the Functions Router\n  /// during fullilment from the designated transmitter node in an OCR round.\n  /// @param requestId The requestId returned by FunctionsClient.sendRequest().\n  /// @param response Aggregated response from the request's source code.\n  /// @param err Aggregated error either from the request's source code or from the execution pipeline.\n  /// @dev Either response or error parameter will be set, but never both.\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/interfaces/IFunctionsRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsResponse} from \"../libraries/FunctionsResponse.sol\";\n\n/// @title Chainlink Functions Router interface.\ninterface IFunctionsRouter {\n  /// @notice The identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  /// @return id - bytes32 id that can be passed to the \"getContractById\" of the Router\n  function getAllowListId() external view returns (bytes32);\n\n  /// @notice Set the identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  function setAllowListId(bytes32 allowListId) external;\n\n  /// @notice Get the flat fee (in Juels of LINK) that will be paid to the Router owner for operation of the network\n  /// @return adminFee\n  function getAdminFee() external view returns (uint72 adminFee);\n\n  /// @notice Sends a request using the provided subscriptionId\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequest(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Sends a request to the proposed contracts\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequestToProposed(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Fulfill the request by:\n  /// - calling back the data that the Oracle returned to the client contract\n  /// - pay the DON for processing the request\n  /// @dev Only callable by the Coordinator contract that is saved in the commitment\n  /// @param response response data from DON consensus\n  /// @param err error from DON consensus\n  /// @param juelsPerGas - current rate of juels/gas\n  /// @param costWithoutFulfillment - The cost of processing the request (in Juels of LINK ), without fulfillment\n  /// @param transmitter - The Node that transmitted the OCR report\n  /// @param commitment - The parameters of the request that must be held consistent between request and response time\n  /// @return fulfillResult -\n  /// @return callbackGasCostJuels -\n  function fulfill(\n    bytes memory response,\n    bytes memory err,\n    uint96 juelsPerGas,\n    uint96 costWithoutFulfillment,\n    address transmitter,\n    FunctionsResponse.Commitment memory commitment\n  ) external returns (FunctionsResponse.FulfillResult, uint96);\n\n  /// @notice Validate requested gas limit is below the subscription max.\n  /// @param subscriptionId subscription ID\n  /// @param callbackGasLimit desired callback gas limit\n  function isValidCallbackGasLimit(uint64 subscriptionId, uint32 callbackGasLimit) external view;\n\n  /// @notice Get the current contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current contract address\n  function getContractById(bytes32 id) external view returns (address);\n\n  /// @notice Get the proposed next contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current or proposed contract address\n  function getProposedContractById(bytes32 id) external view returns (address);\n\n  /// @notice Return the latest proprosal set\n  /// @return ids The identifiers of the contracts to update\n  /// @return to The addresses of the contracts that will be updated to\n  function getProposedContractSet() external view returns (bytes32[] memory, address[] memory);\n\n  /// @notice Proposes one or more updates to the contract routes\n  /// @dev Only callable by owner\n  function proposeContractsUpdate(bytes32[] memory proposalSetIds, address[] memory proposalSetAddresses) external;\n\n  /// @notice Updates the current contract routes to the proposed contracts\n  /// @dev Only callable by owner\n  function updateContracts() external;\n\n  /// @dev Puts the system into an emergency stopped state.\n  /// @dev Only callable by owner\n  function pause() external;\n\n  /// @dev Takes the system out of an emergency stopped state.\n  /// @dev Only callable by owner\n  function unpause() external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {CBOR} from \"../../../vendor/solidity-cborutils/v2.0.0/CBOR.sol\";\n\n/// @title Library for encoding the input data of a Functions request into CBOR\nlibrary FunctionsRequest {\n  using CBOR for CBOR.CBORBuffer;\n\n  uint16 public constant REQUEST_DATA_VERSION = 1;\n  uint256 internal constant DEFAULT_BUFFER_SIZE = 256;\n\n  enum Location {\n    Inline, // Provided within the Request\n    Remote, // Hosted through remote location that can be accessed through a provided URL\n    DONHosted // Hosted on the DON's storage\n  }\n\n  enum CodeLanguage {\n    JavaScript\n    // In future version we may add other languages\n  }\n\n  struct Request {\n    Location codeLocation; // ════════════╸ The location of the source code that will be executed on each node in the DON\n    Location secretsLocation; // ═════════╸ The location of secrets that will be passed into the source code. *Only Remote secrets are supported\n    CodeLanguage language; // ════════════╸ The coding language that the source code is written in\n    string source; // ════════════════════╸ Raw source code for Request.codeLocation of Location.Inline, URL for Request.codeLocation of Location.Remote, or slot decimal number for Request.codeLocation of Location.DONHosted\n    bytes encryptedSecretsReference; // ══╸ Encrypted URLs for Request.secretsLocation of Location.Remote (use addSecretsReference()), or CBOR encoded slotid+version for Request.secretsLocation of Location.DONHosted (use addDONHostedSecrets())\n    string[] args; // ════════════════════╸ String arguments that will be passed into the source code\n    bytes[] bytesArgs; // ════════════════╸ Bytes arguments that will be passed into the source code\n  }\n\n  error EmptySource();\n  error EmptySecrets();\n  error EmptyArgs();\n  error NoInlineSecrets();\n\n  /// @notice Encodes a Request to CBOR encoded bytes\n  /// @param self The request to encode\n  /// @return CBOR encoded bytes\n  function encodeCBOR(Request memory self) internal pure returns (bytes memory) {\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\n\n    buffer.writeString(\"codeLocation\");\n    buffer.writeUInt256(uint256(self.codeLocation));\n\n    buffer.writeString(\"language\");\n    buffer.writeUInt256(uint256(self.language));\n\n    buffer.writeString(\"source\");\n    buffer.writeString(self.source);\n\n    if (self.args.length > 0) {\n      buffer.writeString(\"args\");\n      buffer.startArray();\n      for (uint256 i = 0; i < self.args.length; ++i) {\n        buffer.writeString(self.args[i]);\n      }\n      buffer.endSequence();\n    }\n\n    if (self.encryptedSecretsReference.length > 0) {\n      if (self.secretsLocation == Location.Inline) {\n        revert NoInlineSecrets();\n      }\n      buffer.writeString(\"secretsLocation\");\n      buffer.writeUInt256(uint256(self.secretsLocation));\n      buffer.writeString(\"secrets\");\n      buffer.writeBytes(self.encryptedSecretsReference);\n    }\n\n    if (self.bytesArgs.length > 0) {\n      buffer.writeString(\"bytesArgs\");\n      buffer.startArray();\n      for (uint256 i = 0; i < self.bytesArgs.length; ++i) {\n        buffer.writeBytes(self.bytesArgs[i]);\n      }\n      buffer.endSequence();\n    }\n\n    return buffer.buf.buf;\n  }\n\n  /// @notice Initializes a Chainlink Functions Request\n  /// @dev Sets the codeLocation and code on the request\n  /// @param self The uninitialized request\n  /// @param codeLocation The user provided source code location\n  /// @param language The programming language of the user code\n  /// @param source The user provided source code or a url\n  function initializeRequest(\n    Request memory self,\n    Location codeLocation,\n    CodeLanguage language,\n    string memory source\n  ) internal pure {\n    if (bytes(source).length == 0) revert EmptySource();\n\n    self.codeLocation = codeLocation;\n    self.language = language;\n    self.source = source;\n  }\n\n  /// @notice Initializes a Chainlink Functions Request\n  /// @dev Simplified version of initializeRequest for PoC\n  /// @param self The uninitialized request\n  /// @param javaScriptSource The user provided JS code (must not be empty)\n  function initializeRequestForInlineJavaScript(Request memory self, string memory javaScriptSource) internal pure {\n    initializeRequest(self, Location.Inline, CodeLanguage.JavaScript, javaScriptSource);\n  }\n\n  /// @notice Adds Remote user encrypted secrets to a Request\n  /// @param self The initialized request\n  /// @param encryptedSecretsReference Encrypted comma-separated string of URLs pointing to off-chain secrets\n  function addSecretsReference(Request memory self, bytes memory encryptedSecretsReference) internal pure {\n    if (encryptedSecretsReference.length == 0) revert EmptySecrets();\n\n    self.secretsLocation = Location.Remote;\n    self.encryptedSecretsReference = encryptedSecretsReference;\n  }\n\n  /// @notice Adds DON-hosted secrets reference to a Request\n  /// @param self The initialized request\n  /// @param slotID Slot ID of the user's secrets hosted on DON\n  /// @param version User data version (for the slotID)\n  function addDONHostedSecrets(Request memory self, uint8 slotID, uint64 version) internal pure {\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\n\n    buffer.writeString(\"slotID\");\n    buffer.writeUInt64(slotID);\n    buffer.writeString(\"version\");\n    buffer.writeUInt64(version);\n\n    self.secretsLocation = Location.DONHosted;\n    self.encryptedSecretsReference = buffer.buf.buf;\n  }\n\n  /// @notice Sets args for the user run function\n  /// @param self The initialized request\n  /// @param args The array of string args (must not be empty)\n  function setArgs(Request memory self, string[] memory args) internal pure {\n    if (args.length == 0) revert EmptyArgs();\n\n    self.args = args;\n  }\n\n  /// @notice Sets bytes args for the user run function\n  /// @param self The initialized request\n  /// @param args The array of bytes args (must not be empty)\n  function setBytesArgs(Request memory self, bytes[] memory args) internal pure {\n    if (args.length == 0) revert EmptyArgs();\n\n    self.bytesArgs = args;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsResponse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Library of types that are used for fulfillment of a Functions request\nlibrary FunctionsResponse {\n  // Used to send request information from the Router to the Coordinator\n  struct RequestMeta {\n    bytes data; // ══════════════════╸ CBOR encoded Chainlink Functions request data, use FunctionsRequest library to encode a request\n    bytes32 flags; // ═══════════════╸ Per-subscription flags\n    address requestingContract; // ══╗ The client contract that is sending the request\n    uint96 availableBalance; // ═════╝ Common LINK balance of the subscription that is controlled by the Router to be used for all consumer requests.\n    uint72 adminFee; // ═════════════╗ Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\n    uint64 subscriptionId; //        ║ Identifier of the billing subscription that will be charged for the request\n    uint64 initiatedRequests; //     ║ The number of requests that have been started\n    uint32 callbackGasLimit; //      ║ The amount of gas that the callback to the consuming contract will be given\n    uint16 dataVersion; // ══════════╝ The version of the structure of the CBOR encoded request data\n    uint64 completedRequests; // ════╗ The number of requests that have successfully completed or timed out\n    address subscriptionOwner; // ═══╝ The owner of the billing subscription\n  }\n\n  enum FulfillResult {\n    FULFILLED, // 0\n    USER_CALLBACK_ERROR, // 1\n    INVALID_REQUEST_ID, // 2\n    COST_EXCEEDS_COMMITMENT, // 3\n    INSUFFICIENT_GAS_PROVIDED, // 4\n    SUBSCRIPTION_BALANCE_INVARIANT_VIOLATION, // 5\n    INVALID_COMMITMENT // 6\n  }\n\n  struct Commitment {\n    bytes32 requestId; // ═════════════════╸ A unique identifier for a Chainlink Functions request\n    address coordinator; // ═══════════════╗ The Coordinator contract that manages the DON that is servicing a request\n    uint96 estimatedTotalCostJuels; // ════╝ The maximum cost in Juels (1e18) of LINK that will be charged to fulfill a request\n    address client; // ════════════════════╗ The client contract that sent the request\n    uint64 subscriptionId; //              ║ Identifier of the billing subscription that will be charged for the request\n    uint32 callbackGasLimit; // ═══════════╝ The amount of gas that the callback to the consuming contract will be given\n    uint72 adminFee; // ═══════════════════╗ Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\n    uint72 donFee; //                      ║ Fee (in Juels of LINK) that will be split between Node Operators for servicing a request\n    uint40 gasOverheadBeforeCallback; //   ║ Represents the average gas execution cost before the fulfillment callback.\n    uint40 gasOverheadAfterCallback; //    ║ Represents the average gas execution cost after the fulfillment callback.\n    uint32 timeoutTimestamp; // ═══════════╝ The timestamp at which a request will be eligible to be timed out\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/@ensdomains/buffer/v0.1.0/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}"
    },
    "@chainlink/contracts/src/v0.8/vendor/solidity-cborutils/v2.0.0/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../@ensdomains/buffer/v0.1.0/Buffer.sol\";\n\n/**\n* @dev A library for populating CBOR encoded payload in Solidity.\n*\n* https://datatracker.ietf.org/doc/html/rfc7049\n*\n* The library offers various write* and start* methods to encode values of different types.\n* The resulted buffer can be obtained with data() method.\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\n* in an invalid CBOR if start/write/end flow is violated.\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\n* except for nested start/end pairs.\n*/\n\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    struct CBORBuffer {\n        Buffer.buffer buf;\n        uint256 depth;\n    }\n\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    uint8 private constant CBOR_FALSE = 20;\n    uint8 private constant CBOR_TRUE = 21;\n    uint8 private constant CBOR_NULL = 22;\n    uint8 private constant CBOR_UNDEFINED = 23;\n\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\n        Buffer.init(cbor.buf, capacity);\n        cbor.depth = 0;\n        return cbor;\n    }\n\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\n        require(buf.depth == 0, \"Invalid CBOR\");\n        return buf.buf.buf;\n    }\n\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        writeBytes(buf, abi.encode(value));\n    }\n\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\n        if (value < 0) {\n            buf.buf.appendUint8(\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\n            );\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\n        } else {\n            writeUInt256(buf, uint256(value));\n        }\n    }\n\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\n    }\n\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\n        if(value >= 0) {\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        } else{\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\n        }\n    }\n\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.buf.append(value);\n    }\n\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.buf.append(bytes(value));\n    }\n\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\n    }\n\n    function writeNull(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_NULL);\n    }\n\n    function writeUndefined(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_UNDEFINED);\n    }\n\n    function startArray(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n        buf.depth += 1;\n    }\n\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\n    }\n\n    function startMap(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n        buf.depth += 1;\n    }\n\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\n    }\n\n    function endSequence(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n        buf.depth -= 1;\n    }\n\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\n        writeString(buf, key);\n        writeString(buf, value);\n    }\n\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\n        writeString(buf, key);\n        writeBytes(buf, value);\n    }\n\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\n        writeString(buf, key);\n        writeUInt256(buf, value);\n    }\n\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\n        writeString(buf, key);\n        writeInt256(buf, value);\n    }\n\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\n        writeString(buf, key);\n        writeUInt64(buf, value);\n    }\n\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\n        writeString(buf, key);\n        writeInt64(buf, value);\n    }\n\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\n        writeString(buf, key);\n        writeBool(buf, value);\n    }\n\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeNull(buf);\n    }\n\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeUndefined(buf);\n    }\n\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startMap(buf);\n    }\n\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startArray(buf);\n    }\n\n    function writeFixedNumeric(\n        CBORBuffer memory buf,\n        uint8 major,\n        uint64 value\n    ) private pure {\n        if (value <= 23) {\n            buf.buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 24));\n            buf.buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 25));\n            buf.buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 26));\n            buf.buf.appendInt(value, 4);\n        } else {\n            buf.buf.appendUint8(uint8((major << 5) | 27));\n            buf.buf.appendInt(value, 8);\n        }\n    }\n\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\n        private\n        pure\n    {\n        buf.buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\n        private\n        pure\n    {\n        writeFixedNumeric(buf, major, length);\n    }\n\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\n    }\n}"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/test/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) {\n        _mint(msg.sender, initialSupply);\n    }\n    \n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n}\n"
    },
    "contracts/UniswapHook_Conflux.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n// Re-export the hook so Hardhat picks it up with npm-based deps\nimport \"../uniswap-v4/lib/uniswap-hooks/src/base/BaseHook.sol\";\n\nimport {Conflux} from \"../uniswap-v4/src/Conflux.sol\";\n\ncontract UniswapHook_Conflux is Conflux {\n  constructor(\n    IPoolManager poolManager,\n    address router,\n    bytes32 donId,\n    address rebateToken\n  ) Conflux(poolManager, router, donId, rebateToken) {}\n}\n"
    },
    "contracts/v4/base/DaemonRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\nimport {IDaemon} from \"../interfaces/IDaemon.sol\";\nimport {ZeroAddress, DuplicateDaemon, CapacityExceeded, IdDoesNotExist, NotExist, DaemonIsBanned, NotDaemonOwner, CountInvalid, StartInvalid} from \"./Errors.sol\";\n\ncontract DaemonRegistry {\n  event Added(address indexed target, uint16 id);\n  event ActivationChanged(address indexed target, uint16 id, bool active);\n  event DaemonBanned(address indexed target, uint16 id);\n\n  // List of daemon contract addresses, index also serves as id (uint16)\n  address[] private _daemonAddresses;\n  mapping(address => bool) public exists;\n  mapping(address => uint16) public addressToId;\n  mapping(uint16 => address) public idToAddress;\n  mapping(address => bool) public active;\n  mapping(address => address) public daemonOwner; // daemon address => owner address\n  mapping(address => bool) public banned; // banned daemon cannot be activated\n\n  // Compact activation bitmap: bit i corresponds to id i\n  // Stored as 256-bit words for efficient updates\n  mapping(uint256 => uint256) private _activationBitmaskWords;\n  uint256 public bitWordCount; // number of 256-bit words used to cover current ids\n\n  function _ensureBitCapacity(uint256 numberOfIds) internal {\n    uint256 needed = (numberOfIds + 255) / 256;\n    if (needed > bitWordCount) {\n      bitWordCount = needed;\n    }\n  }\n\n  function _setActiveBit(uint16 daemonId, bool isActive) internal {\n    uint256 wordIndex = uint256(daemonId) / 256;\n    uint256 bitIndex = uint256(daemonId) % 256;\n    uint256 bitMask = (uint256(1) << bitIndex);\n    uint256 currentWord = _activationBitmaskWords[wordIndex];\n    if (isActive) {\n      currentWord |= bitMask;\n    } else {\n      currentWord &= ~bitMask;\n    }\n    _activationBitmaskWords[wordIndex] = currentWord;\n  }\n\n  // Note: bulk add is handled in the hook to also capture per-daemon owners\n\n  // TODO: ADD OnlyHookOwner\n  function _add(address daemon, address owner) internal {\n    if (daemon == address(0)) revert ZeroAddress();\n    if (exists[daemon]) revert DuplicateDaemon();\n    if (_daemonAddresses.length >= 1200) revert CapacityExceeded();\n    uint16 daemonId = uint16(_daemonAddresses.length);\n    exists[daemon] = true;\n    addressToId[daemon] = daemonId;\n    idToAddress[daemonId] = daemon;\n    _daemonAddresses.push(daemon);\n    daemonOwner[daemon] = owner;\n    emit Added(daemon, daemonId);\n    // active[daemon] is false by default\n    _ensureBitCapacity(_daemonAddresses.length);\n  }\n\n  function length() external view returns (uint256) {\n    return _daemonAddresses.length;\n  }\n\n  function getAt(uint256 index) external view returns (address) {\n    return _daemonAddresses[index];\n  }\n\n  function getAll() external view returns (address[] memory) {\n    return _daemonAddresses;\n  }\n\n  function getById(uint16 daemonId) external view returns (address) {\n    address daemon = idToAddress[daemonId];\n    if (daemon == address(0)) revert IdDoesNotExist();\n    return daemon;\n  }\n\n  /// Packed addresses: 20*N bytes\n  function packedAll() external view returns (bytes memory) {\n    return abi.encodePacked(_daemonAddresses);\n  }\n\n  function packedHash() external view returns (bytes32) {\n    return keccak256(abi.encodePacked(_daemonAddresses));\n  }\n\n  function _setActive(address daemon, bool isActive) internal {\n    if (!exists[daemon]) revert NotExist();\n    if (isActive) {\n      if (banned[daemon]) revert DaemonIsBanned();\n    }\n    uint16 daemonId = addressToId[daemon];\n    active[daemon] = isActive;\n    _setActiveBit(daemonId, isActive);\n    emit ActivationChanged(daemon, daemonId, isActive);\n  }\n\n  function _setActiveById(uint16 daemonId, bool isActive) internal {\n    address daemon = idToAddress[daemonId];\n    if (daemon == address(0)) revert NotExist();\n    if (isActive) {\n      if (banned[daemon]) revert DaemonIsBanned();\n    }\n    active[daemon] = isActive;\n    _setActiveBit(daemonId, isActive);\n    emit ActivationChanged(daemon, daemonId, isActive);\n  }\n\n  // Internal ban API for hook admin: disables daemon and prevents later activation by owner\n  function _banDaemon(address daemon) internal {\n    if (!exists[daemon]) revert NotExist();\n    uint16 daemonId = addressToId[daemon];\n    banned[daemon] = true;\n    if (active[daemon]) {\n      active[daemon] = false;\n      _setActiveBit(daemonId, false);\n      emit ActivationChanged(daemon, daemonId, false);\n    }\n    emit DaemonBanned(daemon, daemonId);\n  }\n\n  // Single-activation APIs restricted to daemon owner\n  function setActive(address daemon, bool isActive) external {\n    if (!exists[daemon]) revert NotExist();\n    if (msg.sender != daemonOwner[daemon]) revert NotDaemonOwner();\n    _setActive(daemon, isActive);\n  }\n\n  function setActiveById(uint16 daemonId, bool isActive) external {\n    address daemon = idToAddress[daemonId];\n    if (daemon == address(0)) revert NotExist();\n    if (msg.sender != daemonOwner[daemon]) revert NotDaemonOwner();\n    _setActive(daemon, isActive);\n  }\n\n  // TODO: ADD OnlyHookOwner\n  function _activateMany(address[] calldata daemonAddresses) internal {\n    for (uint256 index = 0; index < daemonAddresses.length; index++) {\n      address daemon = daemonAddresses[index];\n      if (exists[daemon] && !active[daemon]) {\n        active[daemon] = true;\n        _setActiveBit(addressToId[daemon], true);\n        emit ActivationChanged(daemon, addressToId[daemon], true);\n      }\n    }\n  }\n\n  // TODO: ADD OnlyHookOwner\n  function _deactivateMany(address[] calldata daemonAddresses) internal {\n    for (uint256 index = 0; index < daemonAddresses.length; index++) {\n      address daemon = daemonAddresses[index];\n      if (exists[daemon] && active[daemon]) {\n        active[daemon] = false;\n        _setActiveBit(addressToId[daemon], false);\n        emit ActivationChanged(daemon, addressToId[daemon], false);\n      }\n    }\n  }\n\n  /// Packed pairs: [id(2) | address(20)] * N\n  /// - id is uint16, big-endian (high byte first)\n  function packedPairs() external view returns (bytes memory out) {\n    uint256 total = _daemonAddresses.length;\n    out = new bytes(total * 22);\n    for (uint256 index = 0; index < total; index++) {\n      uint16 daemonId = addressToId[_daemonAddresses[index]];\n      uint256 base = 32 + index * 22;\n      // write id (2 bytes, big-endian)\n      assembly {\n        let p := add(out, base)\n        mstore8(p, byte(1, daemonId))         // high byte\n        mstore8(add(p, 1), byte(0, daemonId)) // low byte\n      }\n      // write address (20 bytes)\n      bytes20 daemonBytes = bytes20(_daemonAddresses[index]);\n      for (uint256 j = 0; j < 20; j++) {\n        bytes1 b = daemonBytes[j];\n        assembly {\n          mstore8(add(add(out, base), add(2, j)), byte(0, b))\n        }\n      }\n    }\n  }\n\n  function packedPairsHash() external view returns (bytes32) {\n    return keccak256(this.packedPairs());\n  }\n\n  /// Returns compact activation bitmap. Bit i corresponds to id i.\n  /// Length of the returned bytes is ceil(length()/8).\n  function activationBitmap() external view returns (bytes memory out) {\n    uint256 total = _daemonAddresses.length;\n    uint256 byteLen = (total + 7) / 8;\n    out = new bytes(byteLen);\n    for (uint256 index = 0; index < total; index++) {\n      if (active[_daemonAddresses[index]]) {\n        uint256 byteIndex = index / 8;\n        uint256 bitIndex = index % 8;\n        uint8 cur = uint8(out[byteIndex]);\n        uint8 mask = uint8(1) << uint8(bitIndex);\n        out[byteIndex] = bytes1(cur | mask);\n      }\n    }\n  }\n\n  function activationMeta() external view returns (uint256 total, bytes memory bitmap) {\n    total = _daemonAddresses.length;\n    bitmap = this.activationBitmap();\n  }\n\n  function aggregatePointsRange(\n    uint256 start,\n    uint256 count,\n    uint256 blockNumber\n  ) external view returns (int128[] memory points) {\n    if (!(count > 0 && count <= 800)) revert CountInvalid();\n    uint256 total = _daemonAddresses.length;\n    if (start > total) revert StartInvalid();\n    uint256 available = total > start ? total - start : 0;\n    uint256 toTake = count < available ? count : available;\n    points = new int128[](toTake);\n    if (toTake == 0) {\n      return points;\n    }\n    for (uint256 index = 0; index < toTake; index++) {\n      address daemon = _daemonAddresses[start + index];\n      if (!active[daemon]) {\n        points[index] = 0;\n        continue;\n      }\n      try IDaemon(daemon).getRebateAmount(blockNumber) returns (int128 value) {\n        points[index] = value;\n      } catch {\n        points[index] = 0;\n      }\n    }\n  }\n\n  /// Overload for Chainlink Functions script compatibility: uses current block number and returns uint128[]\n  function aggregatePointsRange(uint256 start, uint256 count) external view returns (uint128[] memory points) {\n    int128[] memory signedPoints = this.aggregatePointsRange(start, count, block.number);\n    points = new uint128[](signedPoints.length);\n    for (uint256 i = 0; i < signedPoints.length; i++) {\n      int128 value = signedPoints[i];\n      points[i] = value > 0 ? uint128(uint256(int256(value))) : uint128(0);\n    }\n  }\n\n  /// Aggregate getRebateAmount() for all addresses in id order\n  function aggregatePointsAll(uint256 blockNumber) external view returns (int128[] memory points) {\n    uint256 total = _daemonAddresses.length;\n    points = new int128[](total);\n    for (uint256 index = 0; index < total; index++) {\n      address daemon = _daemonAddresses[index];\n      try IDaemon(daemon).getRebateAmount(blockNumber) returns (int128 value) {\n        points[index] = value;\n      } catch {\n        points[index] = 0;\n      }\n    }\n  }\n\n  /// Aggregate getRebateAmount() for all addresses in id order, returning 0 for inactive\n  function aggregatePointsMasked(uint256 blockNumber) external view returns (int128[] memory points) {\n    uint256 total = _daemonAddresses.length;\n    points = new int128[](total);\n    for (uint256 index = 0; index < total; index++) {\n      address daemon = _daemonAddresses[index];\n      if (active[daemon]) {\n        try IDaemon(daemon).getRebateAmount(blockNumber) returns (int128 value) {\n          points[index] = value;\n        } catch {\n          points[index] = 0;\n        }\n      } else {\n        points[index] = 0;\n      }\n    }\n  }\n}\n"
    },
    "contracts/v4/base/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// Common custom errors to reduce bytecode size compared to revert strings\n\nerror NotHookOwner();\nerror ZeroAddress();\nerror ZeroValue();\nerror UnknownRequest();\nerror FunctionsError();\nerror AlreadyInitialized();\nerror IndexOutOfBounds();\nerror EmptyTop();\nerror LengthMismatch();\n\nerror DuplicateDaemon();\nerror CapacityExceeded();\nerror IdDoesNotExist();\nerror NotExist();\nerror DaemonIsBanned();\nerror NotDaemonOwner();\nerror CountInvalid();\nerror StartInvalid();\nerror NotOwner();\nerror NotAuthorized();"
    },
    "contracts/v4/base/HookOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\nimport {NotHookOwner, ZeroAddress} from \"./Errors.sol\";\n\n/// @notice Abstract contract for hook-level ownership management\nabstract contract HookOwnable {\n  address public hookOwner;\n\n  event HookOwnerTransferred(address indexed previousOwner, address indexed newOwner);\n  event HookOwnerRenounced(address indexed previousOwner);\n\n  /// @dev Internal setter for initial owner (used in constructor)\n  function _setHookOwner(address owner) internal {\n    hookOwner = owner;\n    emit HookOwnerTransferred(address(0), owner);\n  }\n\n  /// @notice Reverts if caller is not the hook owner\n  modifier onlyHookOwner() {\n    if (msg.sender != hookOwner) revert NotHookOwner();\n    _;\n  }\n\n  /// @notice Transfer hook ownership to a new address\n  function transferHookOwnership(address newOwner) external onlyHookOwner {\n    if (newOwner == address(0)) revert ZeroAddress();\n    address prev = hookOwner;\n    hookOwner = newOwner;\n    emit HookOwnerTransferred(prev, newOwner);\n  }\n\n  /// @notice Renounce ownership of the hook\n  function renounceHookOwnership() external onlyHookOwner {\n    address prev = hookOwner;\n    hookOwner = address(0);\n    emit HookOwnerRenounced(prev);\n  }\n}\n"
    },
    "contracts/v4/base/PoolOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n// Mock PoolKey and PoolId for testing\nstruct PoolKey {\n    address currency0;\n    address currency1;\n    uint24 fee;\n    int24 tickSpacing;\n    address hook;\n}\n\ntype PoolId is bytes32;\n\nlibrary PoolIdLibrary {\n    function toId(PoolKey memory key) internal pure returns (PoolId) {\n        return PoolId.wrap(keccak256(abi.encode(key)));\n    }\n}\n\n/// @notice Abstract contract for per-pool ownership management\nabstract contract PoolOwnable {\n  using PoolIdLibrary for PoolKey;\n  mapping(PoolId => address) private _owners;\n\n  event PoolOwnerTransferred(PoolId indexed poolId, address indexed previousOwner, address indexed newOwner);\n  event PoolOwnerRenounced(PoolId indexed poolId, address indexed previousOwner);\n\n  /// @dev Internal setter for initial owner (used in afterInitialize)\n  function _setPoolOwner(PoolKey calldata key, address owner) internal {\n    PoolId id = key.toId();\n    _owners[id] = owner;\n    emit PoolOwnerTransferred(id, address(0), owner);\n  }\n\n  /// @notice Returns the owner for a given pool\n  function poolOwner(PoolKey calldata key) public view returns (address) {\n    return _owners[key.toId()];\n  }\n\n  /// @notice Reverts if caller is not the owner of the pool\n  modifier onlyPoolOwner(PoolKey calldata key) {\n    require(msg.sender == poolOwner(key), \"PoolOwnable: caller is not the pool owner\");\n    _;\n  }\n\n  /// @notice Transfer pool ownership to a new address\n  function transferPoolOwnership(PoolKey calldata key, address newOwner) external onlyPoolOwner(key) {\n    require(newOwner != address(0), \"PoolOwnable: new owner is zero address\");\n    PoolId id = key.toId();\n    address prev = _owners[id];\n    _owners[id] = newOwner;\n    emit PoolOwnerTransferred(id, prev, newOwner);\n  }\n\n  /// @notice Renounce ownership of the pool\n  function renouncePoolOwnership(PoolKey calldata key) external onlyPoolOwner(key) {\n    PoolId id = key.toId();\n    address prev = _owners[id];\n    _owners[id] = address(0);\n    emit PoolOwnerRenounced(id, prev);\n  }\n}\n"
    },
    "contracts/v4/ConfluxHookSimple.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport {HookOwnable} from \"./base/HookOwnable.sol\";\nimport {IDaemon} from \"./interfaces/IDaemon.sol\";\n\ninterface ITopOracle {\n  function epochDurationBlocks() external view returns (uint256);\n  function topEpoch() external view returns (uint64);\n  function topCount() external view returns (uint16);\n  function getCurrentTop() external view returns (address);\n  function iterNextTop() external;\n  function maybeRequestTopUpdate() external;\n}\n\ninterface IDaemonRegistryModerated {\n  function addressToId(address daemon) external view returns (uint16);\n  function setActiveFromHook(address daemon, bool isActive) external;\n  function banFromHook(address daemon) external;\n  function banned(address daemon) external view returns (bool);\n}\n\ncontract ConfluxHookSimple is ReentrancyGuard {\n  // Keep events as they were (they are \"cheap\" for runtime)\n  event RebateDisabled(uint16 indexed daemonId, string reason);\n  event RebateExecuted(uint16 indexed daemonId, uint128 amount);\n  event DaemonJobSuccess(uint16 indexed daemonId);\n  event DaemonJobFailure(uint16 indexed daemonId, string reason);\n\n  // Addresses of extracted modules and rebate token\n  ITopOracle public immutable topOracle;\n  IDaemonRegistryModerated public immutable registry;\n  address public immutable rebateToken;\n  address public immutable poolManager;\n\n  // Rebate management per pools + rebate time telemetry\n  mapping(bytes32 => bool) public isRebateEnabled;\n  mapping(bytes32 => bool) public isRebateToken0; // true if rebate token is currency0, false if currency1\n  mapping(uint16 => uint256) public lastTimeRebateCommitted;\n\n  // Control \"exhaustion\" within a single top epoch\n  uint64 private lastTopEpochSeen;\n  uint16 private processedInTopEpoch;\n\n  constructor(\n    address _poolManager,\n    address _topOracle,\n    address _registry,\n    address _rebateToken\n  ) {\n    poolManager = _poolManager;\n    topOracle = ITopOracle(_topOracle);\n    registry = IDaemonRegistryModerated(_registry);\n    rebateToken = _rebateToken;\n  }\n\n  // Simple pool key structure for testing\n  struct PoolKey {\n    address currency0;\n    address currency1;\n    uint24 fee;\n    int24 tickSpacing;\n    address hook;\n  }\n\n  function getPoolId(PoolKey memory key) public pure returns (bytes32) {\n    return keccak256(abi.encode(key));\n  }\n\n  function _afterInitialize(address sender, PoolKey memory key) internal {\n    // Ensure pool contains the rebate token\n    address token0 = key.currency0;\n    address token1 = key.currency1;\n    require(\n        token0 == rebateToken || token1 == rebateToken,\n        \"ConfluxHook: Pool must contain rebate token\"\n    );\n    \n    bytes32 poolId = getPoolId(key);\n    isRebateEnabled[poolId] = true;\n    isRebateToken0[poolId] = (token0 == rebateToken);\n  }\n\n  function _beforeSwap(\n    PoolKey memory key,\n    bool zeroForOne\n  ) internal nonReentrant returns (int128 specDelta, int128 unspecDelta) {\n    // epochs disabled\n    if (topOracle.epochDurationBlocks() == 0) {\n      return (0, 0);\n    }\n\n    // if necessary — ask TopOracle to initiate update\n    topOracle.maybeRequestTopUpdate();\n\n    // detect start of new top epoch\n    uint64 epoch = topOracle.topEpoch();\n    if (epoch != lastTopEpochSeen) {\n      lastTopEpochSeen = epoch;\n      processedInTopEpoch = 0;\n    }\n\n    uint16 count = topOracle.topCount();\n    if (count == 0 || processedInTopEpoch >= count) {\n      return (0, 0);\n    }\n\n    address rebatePayer = topOracle.getCurrentTop();\n\n    // Check if daemon is banned - if so, skip to next daemon\n    if (registry.banned(rebatePayer)) {\n      processedInTopEpoch++;\n      topOracle.iterNextTop();\n      return (0, 0);\n    }\n\n    // Get the pre-computed rebate token position for this pool\n    bytes32 poolId = getPoolId(key);\n    bool rebateTokenIs0 = isRebateToken0[poolId];\n\n    // Is rebate enabled on the pool?\n    if (!isRebateEnabled[poolId]) {\n      return (0, 0);\n    }\n\n    // Get rebate amount with low-level staticcall (saves bytecode compared to try/catch)\n    (bool okAmt, bytes memory rawAmt) =\n      rebatePayer.staticcall(abi.encodeWithSelector(IDaemon.getRebateAmount.selector, block.number));\n    if (!okAmt || rawAmt.length < 32) {\n      registry.setActiveFromHook(rebatePayer, false);\n      emit RebateDisabled(registry.addressToId(rebatePayer), \"rebateAmount failed\");\n      processedInTopEpoch++;\n      topOracle.iterNextTop();\n      return (0, 0);\n    }\n    int128 daemonRebateAmount = abi.decode(rawAmt, (int128));\n    if (daemonRebateAmount <= 0) {\n      processedInTopEpoch++;\n      topOracle.iterNextTop();\n      return (0, 0);\n    }\n\n    // Sync balance + attempt transferFrom\n    uint256 balBefore = IERC20(rebateToken).balanceOf(poolManager);\n    uint256 required = uint256(uint128(daemonRebateAmount));\n\n    if (!_tryTransferFrom(rebateToken, rebatePayer, poolManager, required)) {\n      registry.setActiveFromHook(rebatePayer, false);\n      emit RebateDisabled(registry.addressToId(rebatePayer), \"transfer failed\");\n      processedInTopEpoch++;\n      topOracle.iterNextTop();\n      return (0, 0);\n    }\n\n    // Protection against fee-on-transfer\n    uint256 received = IERC20(rebateToken).balanceOf(poolManager) - balBefore;\n    if (received < required) {\n      registry.setActiveFromHook(rebatePayer, false);\n      emit RebateDisabled(registry.addressToId(rebatePayer), \"insufficient received\");\n      processedInTopEpoch++;\n      topOracle.iterNextTop();\n      return (0, 0);\n    }\n\n    uint16 daemonId = registry.addressToId(rebatePayer);\n    lastTimeRebateCommitted[daemonId] = block.number;\n    emit RebateExecuted(daemonId, uint128(received));\n\n    // Start daemon task (rebate is paid regardless of outcome)\n    (bool okJob, ) = rebatePayer.call{gas: 300_000}(abi.encodeWithSelector(IDaemon.accomplishDaemonJob.selector));\n    if (okJob) {\n      emit DaemonJobSuccess(daemonId);\n    } else {\n      emit DaemonJobFailure(daemonId, \"job revert\");\n    }\n\n    // Calculate BeforeSwapDelta — always rebate in rebateToken\n    bool rebateOnSpecified = (zeroForOne && rebateTokenIs0) || (!zeroForOne && !rebateTokenIs0);\n    specDelta = rebateOnSpecified ? -daemonRebateAmount : int128(0);\n    unspecDelta = rebateOnSpecified ? int128(0) : -daemonRebateAmount;\n\n    processedInTopEpoch++;\n    topOracle.iterNextTop();\n  }\n\n  // ---- Admin per-pool\n  function toggleRebate(PoolKey memory key) external {\n    bytes32 poolId = getPoolId(key);\n    isRebateEnabled[poolId] = !isRebateEnabled[poolId];\n  }\n\n  function getRebateState(PoolKey memory key) external view returns (bool) {\n    return isRebateEnabled[getPoolId(key)];\n  }\n\n  // ---- ERC20 helper (kept as you had it)\n  function _tryTransferFrom(address token, address from, address to, uint256 amount) internal returns (bool) {\n    (bool success, bytes memory data) =\n      token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount));\n    if (!success) return false;\n    if (data.length == 0) return true; // non‑standard ERC20\n    if (data.length == 32) return abi.decode(data, (bool));\n    return false;\n  }\n}\n"
    },
    "contracts/v4/DaemonRegistryModerated.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {DaemonRegistry} from \"./base/DaemonRegistry.sol\";\nimport {LengthMismatch, NotOwner, NotAuthorized} from \"./base/Errors.sol\";\n\n/// @title DaemonRegistryModerated\n/// @notice Wrapper over DaemonRegistry:\n///         - owner can add/activate/ban daemons;\n///         - hook contract (hookAuthority) can quickly disable/ban daemons\n///           during errors in operation (transfer fail, bad rebate, etc.).\ncontract DaemonRegistryModerated is DaemonRegistry {\n  address public owner;\n  address public hookAuthority; // hook address with moderation rights\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n  event HookAuthoritySet(address indexed hook);\n\n  modifier onlyOwner() {\n    if (msg.sender != owner) revert NotOwner();\n    _;\n  }\n\n  constructor() {\n    owner = msg.sender;\n    emit OwnershipTransferred(address(0), msg.sender);\n  }\n\n  // ===== Admin (registry owner) =====\n\n  function transferOwnership(address newOwner) external onlyOwner {\n    require(newOwner != address(0), \"zero owner\");\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n  function setHookAuthority(address hook) external onlyOwner {\n    require(hook != address(0), \"zero hook\");\n    hookAuthority = hook;\n    emit HookAuthoritySet(hook);\n  }\n\n  /// Bulk addition of daemons with owner binding\n  function addMany(address[] calldata daemonAddresses, address[] calldata owners) external onlyOwner {\n    if (daemonAddresses.length != owners.length) revert LengthMismatch();\n    for (uint256 i = 0; i < daemonAddresses.length; i++) {\n      _add(daemonAddresses[i], owners[i]);\n    }\n  }\n\n  /// Adding a single daemon\n  function add(address daemon, address owner_) external onlyOwner {\n    _add(daemon, owner_);\n  }\n\n  /// Bulk activation/deactivation\n  function activateMany(address[] calldata daemonAddresses) external onlyOwner {\n    _activateMany(daemonAddresses);\n  }\n\n  function deactivateMany(address[] calldata daemonAddresses) external onlyOwner {\n    _deactivateMany(daemonAddresses);\n  }\n\n  /// Ban daemon (with immediate deactivation)\n  function banDaemon(address daemon) external onlyOwner {\n    _banDaemon(daemon);\n  }\n\n  // ===== Moderation from hook side =====\n\n  /// Hook is allowed to enable/disable daemon during errors in rebate/job\n  function setActiveFromHook(address daemon, bool isActive) external {\n    if (msg.sender != hookAuthority) revert NotAuthorized();\n    _setActive(daemon, isActive);\n  }\n\n  /// Hook is allowed to ban daemon (e.g., for repeated violations)\n  function banFromHook(address daemon) external {\n    if (msg.sender != hookAuthority) revert NotAuthorized();\n    _banDaemon(daemon);\n  }\n}\n"
    },
    "contracts/v4/examples/LinearDaemon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {IDaemon} from \"../interfaces/IDaemon.sol\";\n\n/// @title LinearDaemon\n/// @notice Example implementation of IDaemon with a linear rebate model\n/// Price increases from startPrice to endPrice by priceInterest every growPeriod blocks starting at startBlock\ncontract LinearDaemon is IDaemon {\n  // Parameters (int128 used to match registry expectations)\n  int128 public immutable startPrice; // initial rebate amount\n  int128 public immutable endPrice; // maximum rebate amount (cap)\n  int128 public immutable priceInterest; // increment per period (must be > 0)\n  uint256 public immutable growPeriod; // blocks per period (must be > 0)\n  uint256 public immutable startBlock; // schedule start block\n\n  // Telemetry\n  uint256 public jobsExecuted;\n  uint256 public lastJobBlock;\n\n  event LinearDaemonJobExecuted(address indexed caller, uint256 blockNumber);\n\n  constructor(int128 _startPrice, int128 _endPrice, int128 _priceInterest, uint256 _growPeriod, uint256 _startBlock) {\n    require(_priceInterest > 0, \"interest\");\n    require(_growPeriod > 0, \"period\");\n    require(_endPrice >= _startPrice, \"order\");\n    startPrice = _startPrice;\n    endPrice = _endPrice;\n    priceInterest = _priceInterest;\n    growPeriod = _growPeriod;\n    startBlock = _startBlock;\n  }\n\n  /// @inheritdoc IDaemon\n  function getRebateAmount(uint256 blockNumber) external view returns (int128) {\n    if (blockNumber < startBlock) {\n      return 0;\n    }\n    // Compute number of periods elapsed since last job (or start)\n    uint256 baseline = lastJobBlock;\n    if (baseline < startBlock) baseline = startBlock;\n    uint256 elapsedBlocks = blockNumber - baseline;\n    uint256 periods = elapsedBlocks / growPeriod;\n\n    // Compute startPrice + priceInterest * periods with capping at endPrice\n    int256 increment = int256(priceInterest) * int256(periods);\n    int256 candidate = int256(startPrice) + increment;\n    if (candidate > int256(endPrice)) {\n      candidate = int256(endPrice);\n    }\n    if (candidate < 0) {\n      return 0;\n    }\n    return int128(candidate);\n  }\n\n  /// @inheritdoc IDaemon\n  function accomplishDaemonJob() external {\n    unchecked {\n      jobsExecuted += 1;\n    }\n    lastJobBlock = block.number;\n    emit LinearDaemonJobExecuted(msg.sender, block.number);\n  }\n}\n"
    },
    "contracts/v4/interfaces/IDaemon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IDaemon {\n  function getRebateAmount(uint256 blockNumber) external view returns (int128);\n  function accomplishDaemonJob() external;\n}\n"
    },
    "contracts/v4/mocks/BaseHook.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n// Mock BaseHook for testing purposes\nabstract contract BaseHook {\n    address public immutable poolManager;\n    \n    constructor(address _poolManager) {\n        poolManager = _poolManager;\n    }\n    \n    function getHookPermissions() public pure virtual returns (Hooks.Permissions memory);\n    \n    // Hook function selectors\n    bytes4 public constant beforeInitialize = bytes4(keccak256(\"beforeInitialize(address,PoolKey,uint160,int24)\"));\n    bytes4 public constant afterInitialize = bytes4(keccak256(\"afterInitialize(address,PoolKey,uint160,int24)\"));\n    bytes4 public constant beforeAddLiquidity = bytes4(keccak256(\"beforeAddLiquidity(address,PoolKey,ModifyLiquidityParams,bytes)\"));\n    bytes4 public constant afterAddLiquidity = bytes4(keccak256(\"afterAddLiquidity(address,PoolKey,ModifyLiquidityParams,bytes)\"));\n    bytes4 public constant beforeRemoveLiquidity = bytes4(keccak256(\"beforeRemoveLiquidity(address,PoolKey,ModifyLiquidityParams,bytes)\"));\n    bytes4 public constant afterRemoveLiquidity = bytes4(keccak256(\"afterRemoveLiquidity(address,PoolKey,ModifyLiquidityParams,bytes)\"));\n    bytes4 public constant beforeSwap = bytes4(keccak256(\"beforeSwap(address,PoolKey,SwapParams,bytes)\"));\n    bytes4 public constant afterSwap = bytes4(keccak256(\"afterSwap(address,PoolKey,SwapParams,BalanceDelta,bytes)\"));\n    bytes4 public constant beforeDonate = bytes4(keccak256(\"beforeDonate(address,PoolKey,uint256,uint256,bytes)\"));\n    bytes4 public constant afterDonate = bytes4(keccak256(\"afterDonate(address,PoolKey,uint256,uint256,bytes)\"));\n    bytes4 public constant beforeSwapReturnDelta = bytes4(keccak256(\"beforeSwapReturnDelta(address,PoolKey,SwapParams,bytes)\"));\n    bytes4 public constant afterSwapReturnDelta = bytes4(keccak256(\"afterSwapReturnDelta(address,PoolKey,SwapParams,BalanceDelta,bytes)\"));\n    bytes4 public constant afterAddLiquidityReturnDelta = bytes4(keccak256(\"afterAddLiquidityReturnDelta(address,PoolKey,ModifyLiquidityParams,bytes)\"));\n    bytes4 public constant afterRemoveLiquidityReturnDelta = bytes4(keccak256(\"afterRemoveLiquidityReturnDelta(address,PoolKey,ModifyLiquidityParams,bytes)\"));\n}\n\n// Mock Hooks library\nlibrary Hooks {\n    struct Permissions {\n        bool beforeInitialize;\n        bool afterInitialize;\n        bool beforeAddLiquidity;\n        bool afterAddLiquidity;\n        bool beforeRemoveLiquidity;\n        bool afterRemoveLiquidity;\n        bool beforeSwap;\n        bool afterSwap;\n        bool beforeDonate;\n        bool afterDonate;\n        bool beforeSwapReturnDelta;\n        bool afterSwapReturnDelta;\n        bool afterAddLiquidityReturnDelta;\n        bool afterRemoveLiquidityReturnDelta;\n    }\n}\n\n// Mock types\nstruct PoolKey {\n    address currency0;\n    address currency1;\n    uint24 fee;\n    int24 tickSpacing;\n    address hook;\n}\n\nstruct SwapParams {\n    bool zeroForOne;\n    int256 amountSpecified;\n    uint160 sqrtPriceLimitX96;\n}\n\nstruct ModifyLiquidityParams {\n    int24 tickLower;\n    int24 tickUpper;\n    int256 liquidityDelta;\n}\n\nstruct BalanceDelta {\n    int128 amount0;\n    int128 amount1;\n}\n\nstruct BeforeSwapDelta {\n    int128 amount0Delta;\n    int128 amount1Delta;\n}\n\nlibrary BeforeSwapDeltaLibrary {\n    function ZERO_DELTA() internal pure returns (BeforeSwapDelta memory) {\n        return BeforeSwapDelta(0, 0);\n    }\n}\n\nfunction toBeforeSwapDelta(int128 amount0Delta, int128 amount1Delta) pure returns (BeforeSwapDelta memory) {\n    return BeforeSwapDelta(amount0Delta, amount1Delta);\n}\n\n// Mock Currency\ntype Currency is address;\n\n// Mock PoolId\ntype PoolId is bytes32;\n\nlibrary PoolIdLibrary {\n    function toId(PoolKey memory key) internal pure returns (PoolId) {\n        return PoolId.wrap(keccak256(abi.encode(key)));\n    }\n}\n\n// Mock IPoolManager\ninterface IPoolManager {\n    function sync(Currency currency) external;\n    function settle() external;\n}\n"
    },
    "contracts/v4/TopOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {FunctionsClient} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol\";\n\n// Minimal interface for accessing daemon addresses by id\ninterface IDaemonRegistryView {\n  function getById(uint16 daemonId) external view returns (address);\n  function length() external view returns (uint256);\n}\n\n/**\n * @title TopOracle\n * @notice Stores and updates the \"top\" daemons via Chainlink Functions.\n *         Instead of storing/building the request on the contract, a\n *         pre-prepared CBOR (req.encodeCBOR()) is used, stored\n *         in a template. This saves bytecode and gas.\n */\ncontract TopOracle is FunctionsClient {\n  // === Chainlink Configuration ===\n  bytes32 public donId;\n  address public registry; // daemon registry address (for getById)\n\n  // Owner (simple ownable without dependencies to avoid bloating the code)\n  address public owner;\n  address public hookAuthority; // Hook contract that can call restricted functions\n  \n  modifier onlyOwner() {\n    require(msg.sender == owner, \"only owner\");\n    _;\n  }\n  \n  modifier onlyHookAuthority() {\n    require(msg.sender == hookAuthority, \"only hook authority\");\n    _;\n  }\n\n  event OwnerTransferred(address indexed previousOwner, address indexed newOwner);\n  event RegistryUpdated(address indexed newRegistry);\n  event HookAuthoritySet(address indexed hookAuthority);\n\n  // === Top data (128 ids packed into 8 words) ===\n  uint256[8] public topPacked;   // 16 * 8 ids in 8 * 256-bit words\n  uint16 public topCount;        // [0..128]\n  uint16 public topCursor;       // current index in the top\n  bytes32 public lastRequestId;  // last Functions request\n  uint64 public topEpoch;        // increments on successful update\n  uint256 public epochDurationBlocks;   // epoch duration in blocks (0 — disabled)\n  uint256 public lastEpochStartBlock;   // block when current epoch started\n  bool public hasPendingTopRequest;     // true if request is already sent and waiting for fulfill\n\n  event TopRefreshRequested(uint64 epoch, uint256 atBlock);\n  event TopIdsUpdated(uint16 count);\n\n  // === Request template (prepared CBOR + subId + callbackGas) ===\n  struct RequestTemplate {\n    bytes encodedRequest;     // req.encodeCBOR()\n    uint64 subscriptionId;\n    uint32 callbackGasLimit;\n  }\n  RequestTemplate private _tpl;\n\n  event TemplateUpdated(uint64 subscriptionId, uint32 callbackGasLimit);\n  event EpochDurationUpdated(uint256 blocks);\n\n  constructor(address router, bytes32 _donId, address _registry, address _hookAuthority) FunctionsClient(router) {\n    donId = _donId;\n    registry = _registry;\n    hookAuthority = _hookAuthority;\n    owner = msg.sender;\n    emit OwnerTransferred(address(0), msg.sender);\n    emit RegistryUpdated(_registry);\n    emit HookAuthoritySet(_hookAuthority);\n  }\n\n  // ===== Admin =====\n\n  function transferOwnership(address newOwner) external onlyOwner {\n    require(newOwner != address(0), \"zero owner\");\n    emit OwnerTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n  function setRegistry(address _registry) external onlyOwner {\n    registry = _registry;\n    emit RegistryUpdated(_registry);\n  }\n\n  function setHookAuthority(address _hookAuthority) external onlyOwner {\n    require(_hookAuthority != address(0), \"zero hook authority\");\n    hookAuthority = _hookAuthority;\n    emit HookAuthoritySet(_hookAuthority);\n  }\n\n  /**\n   * @notice Saves a pre-assembled CBOR template for Functions request.\n   *         Assemble req off-chain and pass req.encodeCBOR().\n   */\n  function setRequestTemplate(\n    bytes calldata encodedRequest,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit\n  ) external onlyOwner {\n    require(encodedRequest.length > 0, \"empty template\");\n    require(subscriptionId != 0, \"zero sub\");\n    require(callbackGasLimit != 0, \"zero gas\");\n    _tpl = RequestTemplate(encodedRequest, subscriptionId, callbackGasLimit);\n    emit TemplateUpdated(subscriptionId, callbackGasLimit);\n  }\n\n  /**\n   * @notice Sets the epoch duration (in blocks).\n   */\n  function setEpochDuration(uint256 blocks_) external onlyOwner {\n    require(blocks_ > 0, \"zero epoch\");\n    epochDurationBlocks = blocks_;\n    emit EpochDurationUpdated(blocks_);\n  }\n\n  /**\n   * @notice Initialization: sets epoch duration and first Functions request.\n   *         Convenient to call once after deployment. encodedRequest is already CBOR.\n   */\n  function startRebateEpochs(\n    uint256 initialEpochDurationBlocks,\n    bytes calldata encodedRequest,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit\n  ) external onlyOwner {\n    require(epochDurationBlocks == 0, \"already initialized\");\n    require(initialEpochDurationBlocks > 0, \"zero epoch\");\n    require(encodedRequest.length > 0, \"empty tpl\");\n    require(subscriptionId != 0, \"zero sub\");\n    require(callbackGasLimit != 0, \"zero gas\");\n\n    epochDurationBlocks = initialEpochDurationBlocks;\n    _tpl = RequestTemplate(encodedRequest, subscriptionId, callbackGasLimit);\n\n    // Send first request immediately\n    hasPendingTopRequest = true;\n    lastRequestId = _sendRequest(encodedRequest, subscriptionId, callbackGasLimit, donId);\n    emit TemplateUpdated(subscriptionId, callbackGasLimit);\n    emit EpochDurationUpdated(initialEpochDurationBlocks);\n    emit TopRefreshRequested(topEpoch, block.number);\n  }\n\n  /**\n   * @notice Force update manually (by admin), without waiting for epoch expiration.\n   */\n  function refreshTopNow() external onlyOwner {\n    RequestTemplate memory t = _tpl;\n    require(t.encodedRequest.length != 0, \"tpl not set\");\n    hasPendingTopRequest = true;\n    lastRequestId = _sendRequest(t.encodedRequest, t.subscriptionId, t.callbackGasLimit, donId);\n    emit TopRefreshRequested(topEpoch, block.number);\n  }\n\n  // ===== Auto-trigger from on-chain side (called by hook) =====\n\n  /**\n   * @notice If epoch has expired and there is no pending request — sends new Functions request,\n   *         using saved CBOR template. This is NO LONGER a mockup.\n   */\n  function maybeRequestTopUpdate() external onlyHookAuthority {\n    if (epochDurationBlocks == 0) return;\n\n    bool expired = block.number >= lastEpochStartBlock + epochDurationBlocks;\n    if (expired && !hasPendingTopRequest) {\n      // Check if there are any daemons in the registry to avoid wasting LINK tokens\n      if (registry == address(0)) return;\n      \n      uint256 daemonCount = IDaemonRegistryView(registry).length();\n      if (daemonCount == 0) return; // Skip request if no daemons registered\n      \n      RequestTemplate memory t = _tpl;\n      require(t.encodedRequest.length != 0, \"tpl not set\");\n\n      hasPendingTopRequest = true;\n      lastRequestId = _sendRequest(t.encodedRequest, t.subscriptionId, t.callbackGasLimit, donId);\n\n      emit TopRefreshRequested(topEpoch, block.number);\n    }\n  }\n\n  // ===== Chainlink Functions fulfill =====\n\n  /**\n   * @dev Response processing: write 8 words, recalculate topCount,\n   *      reset cursor, increment epoch and reset pending flag.\n   */\n  function fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal override {\n    require(requestId == lastRequestId, \"UnknownRequest\");\n    require(err.length == 0, \"FunctionsError\");\n\n    uint256[8] memory words = abi.decode(response, (uint256[8]));\n    // 8 SSTORE — one word at a time\n    for (uint256 i = 0; i < 8; i++) {\n      topPacked[i] = words[i];\n    }\n\n    // Calculate real topCount: stop at 0xFFFF\n    uint16 count = 0;\n    for (uint256 i = 0; i < 128; i++) {\n      uint256 wordIndex = i / 16;\n      uint256 slot = i % 16;\n      uint256 word = words[wordIndex];\n      uint16 id = uint16((word >> (slot * 16)) & 0xffff);\n      if (id == 0xffff) break;\n      unchecked { count++; }\n    }\n\n    topCount = count;\n    topCursor = 0;\n    topEpoch++;\n    hasPendingTopRequest = false;\n    lastEpochStartBlock = block.number;\n\n    emit TopIdsUpdated(topCount);\n  }\n\n  // ===== View / Iteration for hook =====\n\n  function topIdsAt(uint256 index) external view returns (uint16) {\n    require(index < topCount, \"oob\");\n    uint256 wordIndex = index / 16;\n    uint256 slot = index % 16;\n    uint256 word = topPacked[wordIndex];\n    return uint16((word >> (slot * 16)) & 0xffff);\n  }\n\n  function getCurrentTop() external view returns (address daemon) {\n    require(topCount > 0, \"EmptyTop\");\n    uint256 wordIndex = uint256(topCursor) / 16;\n    uint256 slot = uint256(topCursor) % 16;\n    uint256 word = topPacked[wordIndex];\n    uint16 id = uint16((word >> (slot * 16)) & 0xffff);\n    daemon = IDaemonRegistryView(registry).getById(id);\n  }\n\n  function iterNextTop() external onlyHookAuthority {\n    require(topCount > 0, \"EmptyTop\");\n    unchecked {\n      uint16 next = topCursor + 1;\n      if (next >= topCount) next = 0;\n      topCursor = next;\n    }\n  }\n}\n"
    },
    "uniswap-v4/lib/uniswap-hooks/src/base/BaseHook.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Uniswap Hooks (last updated v0.1.0) (src/base/BaseHook.sol)\n\npragma solidity ^0.8.26;\n\n// External imports\nimport {IHooks} from \"../../../v4-core/src/interfaces/IHooks.sol\";\nimport {BalanceDelta} from \"../../../v4-core/src/types/BalanceDelta.sol\";\nimport {Hooks} from \"../../../v4-core/src/libraries/Hooks.sol\";\nimport {PoolKey} from \"../../../v4-core/src/types/PoolKey.sol\";\nimport {IPoolManager} from \"../../../v4-core/src/interfaces/IPoolManager.sol\";\nimport {BeforeSwapDelta} from \"../../../v4-core/src/types/BeforeSwapDelta.sol\";\nimport {SwapParams, ModifyLiquidityParams} from \"../../../v4-core/src/types/PoolOperation.sol\";\n\n/**\n * @dev Base hook implementation.\n *\n * This contract defines all hook entry points, as well as security and permission helpers.\n * Based on the https://github.com/Uniswap/v4-periphery/blob/main/src/base/hooks/BaseHook.sol[Uniswap v4 periphery implementation].\n *\n * NOTE: Hook entry points must be overridden and implemented by the inheriting hook to be used. Their respective\n * flags must be set to true in the `getHookPermissions` function as well.\n *\n * WARNING: This is experimental software and is provided on an \"as is\" and \"as available\" basis. We do\n * not give any warranties and will not be liable for any losses incurred through any use of this code\n * base.\n *\n * _Available since v0.1.0_\n */\nabstract contract BaseHook is IHooks {\n    /*\n     * @dev The pool manager singleton contract.\n     */\n    IPoolManager public immutable poolManager;\n\n    /**\n     * @dev The hook is not the caller.\n     */\n    error NotSelf();\n\n    /**\n     * @dev The pool is not authorized to use this hook.\n     */\n    error InvalidPool();\n\n    /**\n     * @dev The hook function is not implemented.\n     */\n    error HookNotImplemented();\n\n    /**\n     * @notice Thrown when calling unlockCallback where the caller is not `PoolManager`.\n     */\n    error NotPoolManager();\n\n    /**\n     * @dev Set the pool manager and check that the hook address matches the expected permissions and flags.\n     */\n    constructor(IPoolManager _poolManager) {\n        poolManager = _poolManager;\n        _validateHookAddress(this);\n    }\n\n    /**\n     * @notice Only allow calls from the `PoolManager` contract\n     */\n    modifier onlyPoolManager() {\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\n        _;\n    }\n\n    /**\n     * @dev Restrict the function to only be callable by the hook itself.\n     */\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n        _;\n    }\n\n    /**\n     * @dev Restrict the function to only be called for a valid pool.\n     */\n    modifier onlyValidPools(IHooks hooks) {\n        if (hooks != this) revert InvalidPool();\n        _;\n    }\n\n    /**\n     * @dev Get the hook permissions to signal which hook functions are to be implemented.\n     *\n     * Used at deployment to validate the address correctly represents the expected permissions.\n     *\n     * @return permissions The hook permissions.\n     */\n    function getHookPermissions() public pure virtual returns (Hooks.Permissions memory permissions);\n\n    /**\n     * @dev Validate the hook address against the expected permissions.\n     */\n    function _validateHookAddress(BaseHook hook) internal pure {\n        Hooks.validateHookPermissions(hook, getHookPermissions());\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96)\n        external\n        onlyPoolManager\n        returns (bytes4)\n    {\n        return _beforeInitialize(sender, key, sqrtPriceX96);\n    }\n\n    /**\n     * @dev Hook implementation for `beforeInitialize`, to be overridden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _beforeInitialize(address, PoolKey calldata, uint160) internal virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)\n        external\n        onlyPoolManager\n        returns (bytes4)\n    {\n        return _afterInitialize(sender, key, sqrtPriceX96, tick);\n    }\n\n    /**\n     * @dev Hook implementation for `afterInitialize`, to be overridden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _afterInitialize(address, PoolKey calldata, uint160, int24) internal virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function beforeAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external onlyPoolManager returns (bytes4) {\n        return _beforeAddLiquidity(sender, key, params, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `beforeAddLiquidity`, to be overridden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _beforeAddLiquidity(address, PoolKey calldata, ModifyLiquidityParams calldata, bytes calldata)\n        internal\n        virtual\n        returns (bytes4)\n    {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function beforeRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external onlyPoolManager returns (bytes4) {\n        return _beforeRemoveLiquidity(sender, key, params, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `beforeRemoveLiquidity`, to be overridden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _beforeRemoveLiquidity(address, PoolKey calldata, ModifyLiquidityParams calldata, bytes calldata)\n        internal\n        virtual\n        returns (bytes4)\n    {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        ModifyLiquidityParams calldata params,\n        BalanceDelta delta0,\n        BalanceDelta delta1,\n        bytes calldata hookData\n    ) external onlyPoolManager returns (bytes4, BalanceDelta) {\n        return _afterAddLiquidity(sender, key, params, delta0, delta1, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `afterAddLiquidity`, to be overridden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _afterAddLiquidity(\n        address,\n        PoolKey calldata,\n        ModifyLiquidityParams calldata,\n        BalanceDelta,\n        BalanceDelta,\n        bytes calldata\n    ) internal virtual returns (bytes4, BalanceDelta) {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function afterRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        ModifyLiquidityParams calldata params,\n        BalanceDelta delta0,\n        BalanceDelta delta1,\n        bytes calldata hookData\n    ) external onlyPoolManager returns (bytes4, BalanceDelta) {\n        return _afterRemoveLiquidity(sender, key, params, delta0, delta1, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `afterRemoveLiquidity`, to be overridden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _afterRemoveLiquidity(\n        address,\n        PoolKey calldata,\n        ModifyLiquidityParams calldata,\n        BalanceDelta,\n        BalanceDelta,\n        bytes calldata\n    ) internal virtual returns (bytes4, BalanceDelta) {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function beforeSwap(address sender, PoolKey calldata key, SwapParams calldata params, bytes calldata hookData)\n        external\n        onlyPoolManager\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        return _beforeSwap(sender, key, params, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `beforeSwap`, to be overridden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _beforeSwap(address, PoolKey calldata, SwapParams calldata, bytes calldata)\n        internal\n        virtual\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function afterSwap(\n        address sender,\n        PoolKey calldata key,\n        SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external onlyPoolManager returns (bytes4, int128) {\n        return _afterSwap(sender, key, params, delta, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `afterSwap`, to be overridden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _afterSwap(address, PoolKey calldata, SwapParams calldata, BalanceDelta, bytes calldata)\n        internal\n        virtual\n        returns (bytes4, int128)\n    {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function beforeDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external onlyPoolManager returns (bytes4) {\n        return _beforeDonate(sender, key, amount0, amount1, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `beforeDonate`, to be overridden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _beforeDonate(address, PoolKey calldata, uint256, uint256, bytes calldata)\n        internal\n        virtual\n        returns (bytes4)\n    {\n        revert HookNotImplemented();\n    }\n\n    /**\n     * @inheritdoc IHooks\n     */\n    function afterDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external onlyPoolManager returns (bytes4) {\n        return _afterDonate(sender, key, amount0, amount1, hookData);\n    }\n\n    /**\n     * @dev Hook implementation for `afterDonate`, to be overridden by the inheriting hook. The\n     * flag must be set to true in the `getHookPermissions` function.\n     */\n    function _afterDonate(address, PoolKey calldata, uint256, uint256, bytes calldata)\n        internal\n        virtual\n        returns (bytes4)\n    {\n        revert HookNotImplemented();\n    }\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/interfaces/external/IERC20Minimal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns an account's balance in the token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/interfaces/external/IERC6909Claims.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Interface for claims over a contract balance, wrapped as a ERC6909\ninterface IERC6909Claims {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id, uint256 amount);\n\n    event Transfer(address caller, address indexed from, address indexed to, uint256 indexed id, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                                 FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Owner balance of an id.\n    /// @param owner The address of the owner.\n    /// @param id The id of the token.\n    /// @return amount The balance of the token.\n    function balanceOf(address owner, uint256 id) external view returns (uint256 amount);\n\n    /// @notice Spender allowance of an id.\n    /// @param owner The address of the owner.\n    /// @param spender The address of the spender.\n    /// @param id The id of the token.\n    /// @return amount The allowance of the token.\n    function allowance(address owner, address spender, uint256 id) external view returns (uint256 amount);\n\n    /// @notice Checks if a spender is approved by an owner as an operator\n    /// @param owner The address of the owner.\n    /// @param spender The address of the spender.\n    /// @return approved The approval status.\n    function isOperator(address owner, address spender) external view returns (bool approved);\n\n    /// @notice Transfers an amount of an id from the caller to a receiver.\n    /// @param receiver The address of the receiver.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always, unless the function reverts\n    function transfer(address receiver, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Transfers an amount of an id from a sender to a receiver.\n    /// @param sender The address of the sender.\n    /// @param receiver The address of the receiver.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always, unless the function reverts\n    function transferFrom(address sender, address receiver, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Approves an amount of an id to a spender.\n    /// @param spender The address of the spender.\n    /// @param id The id of the token.\n    /// @param amount The amount of the token.\n    /// @return bool True, always\n    function approve(address spender, uint256 id, uint256 amount) external returns (bool);\n\n    /// @notice Sets or removes an operator for the caller.\n    /// @param operator The address of the operator.\n    /// @param approved The approval status.\n    /// @return bool True, always\n    function setOperator(address operator, bool approved) external returns (bool);\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/interfaces/IExtsload.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Interface for functions to access any storage slot in a contract\ninterface IExtsload {\n    /// @notice Called by external contracts to access granular pool state\n    /// @param slot Key of slot to sload\n    /// @return value The value of the slot as bytes32\n    function extsload(bytes32 slot) external view returns (bytes32 value);\n\n    /// @notice Called by external contracts to access granular pool state\n    /// @param startSlot Key of slot to start sloading from\n    /// @param nSlots Number of slots to load into return value\n    /// @return values List of loaded values.\n    function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes32[] memory values);\n\n    /// @notice Called by external contracts to access sparse pool state\n    /// @param slots List of slots to SLOAD from.\n    /// @return values List of loaded values.\n    function extsload(bytes32[] calldata slots) external view returns (bytes32[] memory values);\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/interfaces/IExttload.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/// @notice Interface for functions to access any transient storage slot in a contract\ninterface IExttload {\n    /// @notice Called by external contracts to access transient storage of the contract\n    /// @param slot Key of slot to tload\n    /// @return value The value of the slot as bytes32\n    function exttload(bytes32 slot) external view returns (bytes32 value);\n\n    /// @notice Called by external contracts to access sparse transient pool state\n    /// @param slots List of slots to tload\n    /// @return values List of loaded values\n    function exttload(bytes32[] calldata slots) external view returns (bytes32[] memory values);\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/interfaces/IHooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {ModifyLiquidityParams, SwapParams} from \"../types/PoolOperation.sol\";\nimport {BeforeSwapDelta} from \"../types/BeforeSwapDelta.sol\";\n\n/// @notice V4 decides whether to invoke specific hooks by inspecting the least significant bits\n/// of the address that the hooks contract is deployed to.\n/// For example, a hooks contract deployed to address: 0x0000000000000000000000000000000000002400\n/// has the lowest bits '10 0100 0000 0000' which would cause the 'before initialize' and 'after add liquidity' hooks to be used.\n/// See the Hooks library for the full spec.\n/// @dev Should only be callable by the v4 PoolManager.\ninterface IHooks {\n    /// @notice The hook called before the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @return bytes4 The function selector for the hook\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96) external returns (bytes4);\n\n    /// @notice The hook called after the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @param tick The current tick after the state of a pool is initialized\n    /// @return bytes4 The function selector for the hook\n    function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick)\n        external\n        returns (bytes4);\n\n    /// @notice The hook called before liquidity is added\n    /// @param sender The initial msg.sender for the add liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for adding liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after liquidity is added\n    /// @param sender The initial msg.sender for the add liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for adding liquidity\n    /// @param delta The caller's balance delta after adding liquidity; the sum of principal delta, fees accrued, and hook delta\n    /// @param feesAccrued The fees accrued since the last time fees were collected from this position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterAddLiquidity(\n        address sender,\n        PoolKey calldata key,\n        ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) external returns (bytes4, BalanceDelta);\n\n    /// @notice The hook called before liquidity is removed\n    /// @param sender The initial msg.sender for the remove liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for removing liquidity\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        ModifyLiquidityParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after liquidity is removed\n    /// @param sender The initial msg.sender for the remove liquidity call\n    /// @param key The key for the pool\n    /// @param params The parameters for removing liquidity\n    /// @param delta The caller's balance delta after removing liquidity; the sum of principal delta, fees accrued, and hook delta\n    /// @param feesAccrued The fees accrued since the last time fees were collected from this position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidity provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BalanceDelta The hook's delta in token0 and token1. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterRemoveLiquidity(\n        address sender,\n        PoolKey calldata key,\n        ModifyLiquidityParams calldata params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) external returns (bytes4, BalanceDelta);\n\n    /// @notice The hook called before a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return BeforeSwapDelta The hook's delta in specified and unspecified currencies. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    /// @return uint24 Optionally override the lp fee, only used if three conditions are met: 1. the Pool has a dynamic fee, 2. the value's 2nd highest bit is set (23rd bit, 0x400000), and 3. the value is less than or equal to the maximum fee (1 million)\n    function beforeSwap(address sender, PoolKey calldata key, SwapParams calldata params, bytes calldata hookData)\n        external\n        returns (bytes4, BeforeSwapDelta, uint24);\n\n    /// @notice The hook called after a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param delta The amount owed to the caller (positive) or owed to the pool (negative)\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    /// @return int128 The hook's delta in unspecified currency. Positive: the hook is owed/took currency, negative: the hook owes/sent currency\n    function afterSwap(\n        address sender,\n        PoolKey calldata key,\n        SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4, int128);\n\n    /// @notice The hook called before donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/interfaces/IPoolManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IHooks} from \"./IHooks.sol\";\nimport {IERC6909Claims} from \"./external/IERC6909Claims.sol\";\nimport {IProtocolFees} from \"./IProtocolFees.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {IExtsload} from \"./IExtsload.sol\";\nimport {IExttload} from \"./IExttload.sol\";\nimport {ModifyLiquidityParams, SwapParams} from \"../types/PoolOperation.sol\";\n\n/// @notice Interface for the PoolManager\ninterface IPoolManager is IProtocolFees, IERC6909Claims, IExtsload, IExttload {\n    /// @notice Thrown when a currency is not netted out after the contract is unlocked\n    error CurrencyNotSettled();\n\n    /// @notice Thrown when trying to interact with a non-initialized pool\n    error PoolNotInitialized();\n\n    /// @notice Thrown when unlock is called, but the contract is already unlocked\n    error AlreadyUnlocked();\n\n    /// @notice Thrown when a function is called that requires the contract to be unlocked, but it is not\n    error ManagerLocked();\n\n    /// @notice Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow\n    error TickSpacingTooLarge(int24 tickSpacing);\n\n    /// @notice Pools must have a positive non-zero tickSpacing passed to #initialize\n    error TickSpacingTooSmall(int24 tickSpacing);\n\n    /// @notice PoolKey must have currencies where address(currency0) < address(currency1)\n    error CurrenciesOutOfOrderOrEqual(address currency0, address currency1);\n\n    /// @notice Thrown when a call to updateDynamicLPFee is made by an address that is not the hook,\n    /// or on a pool that does not have a dynamic swap fee.\n    error UnauthorizedDynamicLPFeeUpdate();\n\n    /// @notice Thrown when trying to swap amount of 0\n    error SwapAmountCannotBeZero();\n\n    ///@notice Thrown when native currency is passed to a non native settlement\n    error NonzeroNativeValue();\n\n    /// @notice Thrown when `clear` is called with an amount that is not exactly equal to the open currency delta.\n    error MustClearExactPositiveDelta();\n\n    /// @notice Emitted when a new pool is initialized\n    /// @param id The abi encoded hash of the pool key struct for the new pool\n    /// @param currency0 The first currency of the pool by address sort order\n    /// @param currency1 The second currency of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param hooks The hooks contract address for the pool, or address(0) if none\n    /// @param sqrtPriceX96 The price of the pool on initialization\n    /// @param tick The initial tick of the pool corresponding to the initialized price\n    event Initialize(\n        PoolId indexed id,\n        Currency indexed currency0,\n        Currency indexed currency1,\n        uint24 fee,\n        int24 tickSpacing,\n        IHooks hooks,\n        uint160 sqrtPriceX96,\n        int24 tick\n    );\n\n    /// @notice Emitted when a liquidity position is modified\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that modified the pool\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param liquidityDelta The amount of liquidity that was added or removed\n    /// @param salt The extra data to make positions unique\n    event ModifyLiquidity(\n        PoolId indexed id, address indexed sender, int24 tickLower, int24 tickUpper, int256 liquidityDelta, bytes32 salt\n    );\n\n    /// @notice Emitted for swaps between currency0 and currency1\n    /// @param id The abi encoded hash of the pool key struct for the pool that was modified\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param amount0 The delta of the currency0 balance of the pool\n    /// @param amount1 The delta of the currency1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of the price of the pool after the swap\n    /// @param fee The swap fee in hundredths of a bip\n    event Swap(\n        PoolId indexed id,\n        address indexed sender,\n        int128 amount0,\n        int128 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick,\n        uint24 fee\n    );\n\n    /// @notice Emitted for donations\n    /// @param id The abi encoded hash of the pool key struct for the pool that was donated to\n    /// @param sender The address that initiated the donate call\n    /// @param amount0 The amount donated in currency0\n    /// @param amount1 The amount donated in currency1\n    event Donate(PoolId indexed id, address indexed sender, uint256 amount0, uint256 amount1);\n\n    /// @notice All interactions on the contract that account deltas require unlocking. A caller that calls `unlock` must implement\n    /// `IUnlockCallback(msg.sender).unlockCallback(data)`, where they interact with the remaining functions on this contract.\n    /// @dev The only functions callable without an unlocking are `initialize` and `updateDynamicLPFee`\n    /// @param data Any data to pass to the callback, via `IUnlockCallback(msg.sender).unlockCallback(data)`\n    /// @return The data returned by the call to `IUnlockCallback(msg.sender).unlockCallback(data)`\n    function unlock(bytes calldata data) external returns (bytes memory);\n\n    /// @notice Initialize the state for a given pool ID\n    /// @dev A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee\n    /// @param key The pool key for the pool to initialize\n    /// @param sqrtPriceX96 The initial square root price\n    /// @return tick The initial tick of the pool\n    function initialize(PoolKey memory key, uint160 sqrtPriceX96) external returns (int24 tick);\n\n    /// @notice Modify the liquidity for the given pool\n    /// @dev Poke by calling with a zero liquidityDelta\n    /// @param key The pool to modify liquidity in\n    /// @param params The parameters for modifying the liquidity\n    /// @param hookData The data to pass through to the add/removeLiquidity hooks\n    /// @return callerDelta The balance delta of the caller of modifyLiquidity. This is the total of both principal, fee deltas, and hook deltas if applicable\n    /// @return feesAccrued The balance delta of the fees generated in the liquidity range. Returned for informational purposes\n    /// @dev Note that feesAccrued can be artificially inflated by a malicious actor and integrators should be careful using the value\n    /// For pools with a single liquidity position, actors can donate to themselves to inflate feeGrowthGlobal (and consequently feesAccrued)\n    /// atomically donating and collecting fees in the same unlockCallback may make the inflated value more extreme\n    function modifyLiquidity(PoolKey memory key, ModifyLiquidityParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta callerDelta, BalanceDelta feesAccrued);\n\n    /// @notice Swap against the given pool\n    /// @param key The pool to swap in\n    /// @param params The parameters for swapping\n    /// @param hookData The data to pass through to the swap hooks\n    /// @return swapDelta The balance delta of the address swapping\n    /// @dev Swapping on low liquidity pools may cause unexpected swap amounts when liquidity available is less than amountSpecified.\n    /// Additionally note that if interacting with hooks that have the BEFORE_SWAP_RETURNS_DELTA_FLAG or AFTER_SWAP_RETURNS_DELTA_FLAG\n    /// the hook may alter the swap input/output. Integrators should perform checks on the returned swapDelta.\n    function swap(PoolKey memory key, SwapParams memory params, bytes calldata hookData)\n        external\n        returns (BalanceDelta swapDelta);\n\n    /// @notice Donate the given currency amounts to the in-range liquidity providers of a pool\n    /// @dev Calls to donate can be frontrun adding just-in-time liquidity, with the aim of receiving a portion donated funds.\n    /// Donors should keep this in mind when designing donation mechanisms.\n    /// @dev This function donates to in-range LPs at slot0.tick. In certain edge-cases of the swap algorithm, the `sqrtPrice` of\n    /// a pool can be at the lower boundary of tick `n`, but the `slot0.tick` of the pool is already `n - 1`. In this case a call to\n    /// `donate` would donate to tick `n - 1` (slot0.tick) not tick `n` (getTickAtSqrtPrice(slot0.sqrtPriceX96)).\n    /// Read the comments in `Pool.swap()` for more information about this.\n    /// @param key The key of the pool to donate to\n    /// @param amount0 The amount of currency0 to donate\n    /// @param amount1 The amount of currency1 to donate\n    /// @param hookData The data to pass through to the donate hooks\n    /// @return BalanceDelta The delta of the caller after the donate\n    function donate(PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        external\n        returns (BalanceDelta);\n\n    /// @notice Writes the current ERC20 balance of the specified currency to transient storage\n    /// This is used to checkpoint balances for the manager and derive deltas for the caller.\n    /// @dev This MUST be called before any ERC20 tokens are sent into the contract, but can be skipped\n    /// for native tokens because the amount to settle is determined by the sent value.\n    /// However, if an ERC20 token has been synced and not settled, and the caller instead wants to settle\n    /// native funds, this function can be called with the native currency to then be able to settle the native currency\n    function sync(Currency currency) external;\n\n    /// @notice Called by the user to net out some value owed to the user\n    /// @dev Will revert if the requested amount is not available, consider using `mint` instead\n    /// @dev Can also be used as a mechanism for free flash loans\n    /// @param currency The currency to withdraw from the pool manager\n    /// @param to The address to withdraw to\n    /// @param amount The amount of currency to withdraw\n    function take(Currency currency, address to, uint256 amount) external;\n\n    /// @notice Called by the user to pay what is owed\n    /// @return paid The amount of currency settled\n    function settle() external payable returns (uint256 paid);\n\n    /// @notice Called by the user to pay on behalf of another address\n    /// @param recipient The address to credit for the payment\n    /// @return paid The amount of currency settled\n    function settleFor(address recipient) external payable returns (uint256 paid);\n\n    /// @notice WARNING - Any currency that is cleared, will be non-retrievable, and locked in the contract permanently.\n    /// A call to clear will zero out a positive balance WITHOUT a corresponding transfer.\n    /// @dev This could be used to clear a balance that is considered dust.\n    /// Additionally, the amount must be the exact positive balance. This is to enforce that the caller is aware of the amount being cleared.\n    function clear(Currency currency, uint256 amount) external;\n\n    /// @notice Called by the user to move value into ERC6909 balance\n    /// @param to The address to mint the tokens to\n    /// @param id The currency address to mint to ERC6909s, as a uint256\n    /// @param amount The amount of currency to mint\n    /// @dev The id is converted to a uint160 to correspond to a currency address\n    /// If the upper 12 bytes are not 0, they will be 0-ed out\n    function mint(address to, uint256 id, uint256 amount) external;\n\n    /// @notice Called by the user to move value from ERC6909 balance\n    /// @param from The address to burn the tokens from\n    /// @param id The currency address to burn from ERC6909s, as a uint256\n    /// @param amount The amount of currency to burn\n    /// @dev The id is converted to a uint160 to correspond to a currency address\n    /// If the upper 12 bytes are not 0, they will be 0-ed out\n    function burn(address from, uint256 id, uint256 amount) external;\n\n    /// @notice Updates the pools lp fees for the a pool that has enabled dynamic lp fees.\n    /// @dev A swap fee totaling MAX_SWAP_FEE (100%) makes exact output swaps impossible since the input is entirely consumed by the fee\n    /// @param key The key of the pool to update dynamic LP fees for\n    /// @param newDynamicLPFee The new dynamic pool LP fee\n    function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/interfaces/IProtocolFees.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Currency} from \"../types/Currency.sol\";\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {PoolKey} from \"../types/PoolKey.sol\";\n\n/// @notice Interface for all protocol-fee related functions in the pool manager\ninterface IProtocolFees {\n    /// @notice Thrown when protocol fee is set too high\n    error ProtocolFeeTooLarge(uint24 fee);\n\n    /// @notice Thrown when collectProtocolFees or setProtocolFee is not called by the controller.\n    error InvalidCaller();\n\n    /// @notice Thrown when collectProtocolFees is attempted on a token that is synced.\n    error ProtocolFeeCurrencySynced();\n\n    /// @notice Emitted when the protocol fee controller address is updated in setProtocolFeeController.\n    event ProtocolFeeControllerUpdated(address indexed protocolFeeController);\n\n    /// @notice Emitted when the protocol fee is updated for a pool.\n    event ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFee);\n\n    /// @notice Given a currency address, returns the protocol fees accrued in that currency\n    /// @param currency The currency to check\n    /// @return amount The amount of protocol fees accrued in the currency\n    function protocolFeesAccrued(Currency currency) external view returns (uint256 amount);\n\n    /// @notice Sets the protocol fee for the given pool\n    /// @param key The key of the pool to set a protocol fee for\n    /// @param newProtocolFee The fee to set\n    function setProtocolFee(PoolKey memory key, uint24 newProtocolFee) external;\n\n    /// @notice Sets the protocol fee controller\n    /// @param controller The new protocol fee controller\n    function setProtocolFeeController(address controller) external;\n\n    /// @notice Collects the protocol fees for a given recipient and currency, returning the amount collected\n    /// @dev This will revert if the contract is unlocked\n    /// @param recipient The address to receive the protocol fees\n    /// @param currency The currency to withdraw\n    /// @param amount The amount of currency to withdraw\n    /// @return amountCollected The amount of currency successfully withdrawn\n    function collectProtocolFees(address recipient, Currency currency, uint256 amount)\n        external\n        returns (uint256 amountCollected);\n\n    /// @notice Returns the current protocol fee controller address\n    /// @return address The current protocol fee controller address\n    function protocolFeeController() external view returns (address);\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/libraries/CustomRevert.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Library for reverting with custom errors efficiently\n/// @notice Contains functions for reverting with custom errors with different argument types efficiently\n/// @dev To use this library, declare `using CustomRevert for bytes4;` and replace `revert CustomError()` with\n/// `CustomError.selector.revertWith()`\n/// @dev The functions may tamper with the free memory pointer but it is fine since the call context is exited immediately\nlibrary CustomRevert {\n    /// @dev ERC-7751 error for wrapping bubbled up reverts\n    error WrappedError(address target, bytes4 selector, bytes reason, bytes details);\n\n    /// @dev Reverts with the selector of a custom error in the scratch space\n    function revertWith(bytes4 selector) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            revert(0, 0x04)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an address argument in the scratch space\n    function revertWith(bytes4 selector, address addr) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(addr, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an int24 argument in the scratch space\n    function revertWith(bytes4 selector, int24 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, signextend(2, value))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with a uint160 argument in the scratch space\n    function revertWith(bytes4 selector, uint160 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(value, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two int24 arguments\n    function revertWith(bytes4 selector, int24 value1, int24 value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), signextend(2, value1))\n            mstore(add(fmp, 0x24), signextend(2, value2))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two uint160 arguments\n    function revertWith(bytes4 selector, uint160 value1, uint160 value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), and(value1, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(fmp, 0x24), and(value2, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two address arguments\n    function revertWith(bytes4 selector, address value1, address value2) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), and(value1, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(fmp, 0x24), and(value2, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @notice bubble up the revert message returned by a call and revert with a wrapped ERC-7751 error\n    /// @dev this method can be vulnerable to revert data bombs\n    function bubbleUpAndRevertWith(\n        address revertingContract,\n        bytes4 revertingFunctionSelector,\n        bytes4 additionalContext\n    ) internal pure {\n        bytes4 wrappedErrorSelector = WrappedError.selector;\n        assembly (\"memory-safe\") {\n            // Ensure the size of the revert data is a multiple of 32 bytes\n            let encodedDataSize := mul(div(add(returndatasize(), 31), 32), 32)\n\n            let fmp := mload(0x40)\n\n            // Encode wrapped error selector, address, function selector, offset, additional context, size, revert reason\n            mstore(fmp, wrappedErrorSelector)\n            mstore(add(fmp, 0x04), and(revertingContract, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(\n                add(fmp, 0x24),\n                and(revertingFunctionSelector, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n            )\n            // offset revert reason\n            mstore(add(fmp, 0x44), 0x80)\n            // offset additional context\n            mstore(add(fmp, 0x64), add(0xa0, encodedDataSize))\n            // size revert reason\n            mstore(add(fmp, 0x84), returndatasize())\n            // revert reason\n            returndatacopy(add(fmp, 0xa4), 0, returndatasize())\n            // size additional context\n            mstore(add(fmp, add(0xa4, encodedDataSize)), 0x04)\n            // additional context\n            mstore(\n                add(fmp, add(0xc4, encodedDataSize)),\n                and(additionalContext, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n            )\n            revert(fmp, add(0xe4, encodedDataSize))\n        }\n    }\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/libraries/Hooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\nimport {LPFeeLibrary} from \"./LPFeeLibrary.sol\";\nimport {BalanceDelta, toBalanceDelta, BalanceDeltaLibrary} from \"../types/BalanceDelta.sol\";\nimport {BeforeSwapDelta, BeforeSwapDeltaLibrary} from \"../types/BeforeSwapDelta.sol\";\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {ModifyLiquidityParams, SwapParams} from \"../types/PoolOperation.sol\";\nimport {ParseBytes} from \"./ParseBytes.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @notice V4 decides whether to invoke specific hooks by inspecting the least significant bits\n/// of the address that the hooks contract is deployed to.\n/// For example, a hooks contract deployed to address: 0x0000000000000000000000000000000000002400\n/// has the lowest bits '10 0100 0000 0000' which would cause the 'before initialize' and 'after add liquidity' hooks to be used.\nlibrary Hooks {\n    using LPFeeLibrary for uint24;\n    using Hooks for IHooks;\n    using SafeCast for int256;\n    using BeforeSwapDeltaLibrary for BeforeSwapDelta;\n    using ParseBytes for bytes;\n    using CustomRevert for bytes4;\n\n    uint160 internal constant ALL_HOOK_MASK = uint160((1 << 14) - 1);\n\n    uint160 internal constant BEFORE_INITIALIZE_FLAG = 1 << 13;\n    uint160 internal constant AFTER_INITIALIZE_FLAG = 1 << 12;\n\n    uint160 internal constant BEFORE_ADD_LIQUIDITY_FLAG = 1 << 11;\n    uint160 internal constant AFTER_ADD_LIQUIDITY_FLAG = 1 << 10;\n\n    uint160 internal constant BEFORE_REMOVE_LIQUIDITY_FLAG = 1 << 9;\n    uint160 internal constant AFTER_REMOVE_LIQUIDITY_FLAG = 1 << 8;\n\n    uint160 internal constant BEFORE_SWAP_FLAG = 1 << 7;\n    uint160 internal constant AFTER_SWAP_FLAG = 1 << 6;\n\n    uint160 internal constant BEFORE_DONATE_FLAG = 1 << 5;\n    uint160 internal constant AFTER_DONATE_FLAG = 1 << 4;\n\n    uint160 internal constant BEFORE_SWAP_RETURNS_DELTA_FLAG = 1 << 3;\n    uint160 internal constant AFTER_SWAP_RETURNS_DELTA_FLAG = 1 << 2;\n    uint160 internal constant AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG = 1 << 1;\n    uint160 internal constant AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG = 1 << 0;\n\n    struct Permissions {\n        bool beforeInitialize;\n        bool afterInitialize;\n        bool beforeAddLiquidity;\n        bool afterAddLiquidity;\n        bool beforeRemoveLiquidity;\n        bool afterRemoveLiquidity;\n        bool beforeSwap;\n        bool afterSwap;\n        bool beforeDonate;\n        bool afterDonate;\n        bool beforeSwapReturnDelta;\n        bool afterSwapReturnDelta;\n        bool afterAddLiquidityReturnDelta;\n        bool afterRemoveLiquidityReturnDelta;\n    }\n\n    /// @notice Thrown if the address will not lead to the specified hook calls being called\n    /// @param hooks The address of the hooks contract\n    error HookAddressNotValid(address hooks);\n\n    /// @notice Hook did not return its selector\n    error InvalidHookResponse();\n\n    /// @notice Additional context for ERC-7751 wrapped error when a hook call fails\n    error HookCallFailed();\n\n    /// @notice The hook's delta changed the swap from exactIn to exactOut or vice versa\n    error HookDeltaExceedsSwapAmount();\n\n    /// @notice Utility function intended to be used in hook constructors to ensure\n    /// the deployed hooks address causes the intended hooks to be called\n    /// @param permissions The hooks that are intended to be called\n    /// @dev permissions param is memory as the function will be called from constructors\n    function validateHookPermissions(IHooks self, Permissions memory permissions) internal pure {\n        if (\n            permissions.beforeInitialize != self.hasPermission(BEFORE_INITIALIZE_FLAG)\n                || permissions.afterInitialize != self.hasPermission(AFTER_INITIALIZE_FLAG)\n                || permissions.beforeAddLiquidity != self.hasPermission(BEFORE_ADD_LIQUIDITY_FLAG)\n                || permissions.afterAddLiquidity != self.hasPermission(AFTER_ADD_LIQUIDITY_FLAG)\n                || permissions.beforeRemoveLiquidity != self.hasPermission(BEFORE_REMOVE_LIQUIDITY_FLAG)\n                || permissions.afterRemoveLiquidity != self.hasPermission(AFTER_REMOVE_LIQUIDITY_FLAG)\n                || permissions.beforeSwap != self.hasPermission(BEFORE_SWAP_FLAG)\n                || permissions.afterSwap != self.hasPermission(AFTER_SWAP_FLAG)\n                || permissions.beforeDonate != self.hasPermission(BEFORE_DONATE_FLAG)\n                || permissions.afterDonate != self.hasPermission(AFTER_DONATE_FLAG)\n                || permissions.beforeSwapReturnDelta != self.hasPermission(BEFORE_SWAP_RETURNS_DELTA_FLAG)\n                || permissions.afterSwapReturnDelta != self.hasPermission(AFTER_SWAP_RETURNS_DELTA_FLAG)\n                || permissions.afterAddLiquidityReturnDelta != self.hasPermission(AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG)\n                || permissions.afterRemoveLiquidityReturnDelta\n                    != self.hasPermission(AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG)\n        ) {\n            HookAddressNotValid.selector.revertWith(address(self));\n        }\n    }\n\n    /// @notice Ensures that the hook address includes at least one hook flag or dynamic fees, or is the 0 address\n    /// @param self The hook to verify\n    /// @param fee The fee of the pool the hook is used with\n    /// @return bool True if the hook address is valid\n    function isValidHookAddress(IHooks self, uint24 fee) internal pure returns (bool) {\n        // The hook can only have a flag to return a hook delta on an action if it also has the corresponding action flag\n        if (!self.hasPermission(BEFORE_SWAP_FLAG) && self.hasPermission(BEFORE_SWAP_RETURNS_DELTA_FLAG)) return false;\n        if (!self.hasPermission(AFTER_SWAP_FLAG) && self.hasPermission(AFTER_SWAP_RETURNS_DELTA_FLAG)) return false;\n        if (!self.hasPermission(AFTER_ADD_LIQUIDITY_FLAG) && self.hasPermission(AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG))\n        {\n            return false;\n        }\n        if (\n            !self.hasPermission(AFTER_REMOVE_LIQUIDITY_FLAG)\n                && self.hasPermission(AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG)\n        ) return false;\n\n        // If there is no hook contract set, then fee cannot be dynamic\n        // If a hook contract is set, it must have at least 1 flag set, or have a dynamic fee\n        return address(self) == address(0)\n            ? !fee.isDynamicFee()\n            : (uint160(address(self)) & ALL_HOOK_MASK > 0 || fee.isDynamicFee());\n    }\n\n    /// @notice performs a hook call using the given calldata on the given hook that doesn't return a delta\n    /// @return result The complete data returned by the hook\n    function callHook(IHooks self, bytes memory data) internal returns (bytes memory result) {\n        bool success;\n        assembly (\"memory-safe\") {\n            success := call(gas(), self, 0, add(data, 0x20), mload(data), 0, 0)\n        }\n        // Revert with FailedHookCall, containing any error message to bubble up\n        if (!success) CustomRevert.bubbleUpAndRevertWith(address(self), bytes4(data), HookCallFailed.selector);\n\n        // The call was successful, fetch the returned data\n        assembly (\"memory-safe\") {\n            // allocate result byte array from the free memory pointer\n            result := mload(0x40)\n            // store new free memory pointer at the end of the array padded to 32 bytes\n            mstore(0x40, add(result, and(add(returndatasize(), 0x3f), not(0x1f))))\n            // store length in memory\n            mstore(result, returndatasize())\n            // copy return data to result\n            returndatacopy(add(result, 0x20), 0, returndatasize())\n        }\n\n        // Length must be at least 32 to contain the selector. Check expected selector and returned selector match.\n        if (result.length < 32 || result.parseSelector() != data.parseSelector()) {\n            InvalidHookResponse.selector.revertWith();\n        }\n    }\n\n    /// @notice performs a hook call using the given calldata on the given hook\n    /// @return int256 The delta returned by the hook\n    function callHookWithReturnDelta(IHooks self, bytes memory data, bool parseReturn) internal returns (int256) {\n        bytes memory result = callHook(self, data);\n\n        // If this hook wasn't meant to return something, default to 0 delta\n        if (!parseReturn) return 0;\n\n        // A length of 64 bytes is required to return a bytes4, and a 32 byte delta\n        if (result.length != 64) InvalidHookResponse.selector.revertWith();\n        return result.parseReturnDelta();\n    }\n\n    /// @notice modifier to prevent calling a hook if they initiated the action\n    modifier noSelfCall(IHooks self) {\n        if (msg.sender != address(self)) {\n            _;\n        }\n    }\n\n    /// @notice calls beforeInitialize hook if permissioned and validates return value\n    function beforeInitialize(IHooks self, PoolKey memory key, uint160 sqrtPriceX96) internal noSelfCall(self) {\n        if (self.hasPermission(BEFORE_INITIALIZE_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.beforeInitialize, (msg.sender, key, sqrtPriceX96)));\n        }\n    }\n\n    /// @notice calls afterInitialize hook if permissioned and validates return value\n    function afterInitialize(IHooks self, PoolKey memory key, uint160 sqrtPriceX96, int24 tick)\n        internal\n        noSelfCall(self)\n    {\n        if (self.hasPermission(AFTER_INITIALIZE_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.afterInitialize, (msg.sender, key, sqrtPriceX96, tick)));\n        }\n    }\n\n    /// @notice calls beforeModifyLiquidity hook if permissioned and validates return value\n    function beforeModifyLiquidity(\n        IHooks self,\n        PoolKey memory key,\n        ModifyLiquidityParams memory params,\n        bytes calldata hookData\n    ) internal noSelfCall(self) {\n        if (params.liquidityDelta > 0 && self.hasPermission(BEFORE_ADD_LIQUIDITY_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.beforeAddLiquidity, (msg.sender, key, params, hookData)));\n        } else if (params.liquidityDelta <= 0 && self.hasPermission(BEFORE_REMOVE_LIQUIDITY_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.beforeRemoveLiquidity, (msg.sender, key, params, hookData)));\n        }\n    }\n\n    /// @notice calls afterModifyLiquidity hook if permissioned and validates return value\n    function afterModifyLiquidity(\n        IHooks self,\n        PoolKey memory key,\n        ModifyLiquidityParams memory params,\n        BalanceDelta delta,\n        BalanceDelta feesAccrued,\n        bytes calldata hookData\n    ) internal returns (BalanceDelta callerDelta, BalanceDelta hookDelta) {\n        if (msg.sender == address(self)) return (delta, BalanceDeltaLibrary.ZERO_DELTA);\n\n        callerDelta = delta;\n        if (params.liquidityDelta > 0) {\n            if (self.hasPermission(AFTER_ADD_LIQUIDITY_FLAG)) {\n                hookDelta = BalanceDelta.wrap(\n                    self.callHookWithReturnDelta(\n                        abi.encodeCall(\n                            IHooks.afterAddLiquidity, (msg.sender, key, params, delta, feesAccrued, hookData)\n                        ),\n                        self.hasPermission(AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG)\n                    )\n                );\n                callerDelta = callerDelta - hookDelta;\n            }\n        } else {\n            if (self.hasPermission(AFTER_REMOVE_LIQUIDITY_FLAG)) {\n                hookDelta = BalanceDelta.wrap(\n                    self.callHookWithReturnDelta(\n                        abi.encodeCall(\n                            IHooks.afterRemoveLiquidity, (msg.sender, key, params, delta, feesAccrued, hookData)\n                        ),\n                        self.hasPermission(AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG)\n                    )\n                );\n                callerDelta = callerDelta - hookDelta;\n            }\n        }\n    }\n\n    /// @notice calls beforeSwap hook if permissioned and validates return value\n    function beforeSwap(IHooks self, PoolKey memory key, SwapParams memory params, bytes calldata hookData)\n        internal\n        returns (int256 amountToSwap, BeforeSwapDelta hookReturn, uint24 lpFeeOverride)\n    {\n        amountToSwap = params.amountSpecified;\n        if (msg.sender == address(self)) return (amountToSwap, BeforeSwapDeltaLibrary.ZERO_DELTA, lpFeeOverride);\n\n        if (self.hasPermission(BEFORE_SWAP_FLAG)) {\n            bytes memory result = callHook(self, abi.encodeCall(IHooks.beforeSwap, (msg.sender, key, params, hookData)));\n\n            // A length of 96 bytes is required to return a bytes4, a 32 byte delta, and an LP fee\n            if (result.length != 96) InvalidHookResponse.selector.revertWith();\n\n            // dynamic fee pools that want to override the cache fee, return a valid fee with the override flag. If override flag\n            // is set but an invalid fee is returned, the transaction will revert. Otherwise the current LP fee will be used\n            if (key.fee.isDynamicFee()) lpFeeOverride = result.parseFee();\n\n            // skip this logic for the case where the hook return is 0\n            if (self.hasPermission(BEFORE_SWAP_RETURNS_DELTA_FLAG)) {\n                hookReturn = BeforeSwapDelta.wrap(result.parseReturnDelta());\n\n                // any return in unspecified is passed to the afterSwap hook for handling\n                int128 hookDeltaSpecified = hookReturn.getSpecifiedDelta();\n\n                // Update the swap amount according to the hook's return, and check that the swap type doesn't change (exact input/output)\n                if (hookDeltaSpecified != 0) {\n                    bool exactInput = amountToSwap < 0;\n                    amountToSwap += hookDeltaSpecified;\n                    if (exactInput ? amountToSwap > 0 : amountToSwap < 0) {\n                        HookDeltaExceedsSwapAmount.selector.revertWith();\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice calls afterSwap hook if permissioned and validates return value\n    function afterSwap(\n        IHooks self,\n        PoolKey memory key,\n        SwapParams memory params,\n        BalanceDelta swapDelta,\n        bytes calldata hookData,\n        BeforeSwapDelta beforeSwapHookReturn\n    ) internal returns (BalanceDelta, BalanceDelta) {\n        if (msg.sender == address(self)) return (swapDelta, BalanceDeltaLibrary.ZERO_DELTA);\n\n        int128 hookDeltaSpecified = beforeSwapHookReturn.getSpecifiedDelta();\n        int128 hookDeltaUnspecified = beforeSwapHookReturn.getUnspecifiedDelta();\n\n        if (self.hasPermission(AFTER_SWAP_FLAG)) {\n            hookDeltaUnspecified += self.callHookWithReturnDelta(\n                abi.encodeCall(IHooks.afterSwap, (msg.sender, key, params, swapDelta, hookData)),\n                self.hasPermission(AFTER_SWAP_RETURNS_DELTA_FLAG)\n            ).toInt128();\n        }\n\n        BalanceDelta hookDelta;\n        if (hookDeltaUnspecified != 0 || hookDeltaSpecified != 0) {\n            hookDelta = (params.amountSpecified < 0 == params.zeroForOne)\n                ? toBalanceDelta(hookDeltaSpecified, hookDeltaUnspecified)\n                : toBalanceDelta(hookDeltaUnspecified, hookDeltaSpecified);\n\n            // the caller has to pay for (or receive) the hook's delta\n            swapDelta = swapDelta - hookDelta;\n        }\n        return (swapDelta, hookDelta);\n    }\n\n    /// @notice calls beforeDonate hook if permissioned and validates return value\n    function beforeDonate(IHooks self, PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        internal\n        noSelfCall(self)\n    {\n        if (self.hasPermission(BEFORE_DONATE_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.beforeDonate, (msg.sender, key, amount0, amount1, hookData)));\n        }\n    }\n\n    /// @notice calls afterDonate hook if permissioned and validates return value\n    function afterDonate(IHooks self, PoolKey memory key, uint256 amount0, uint256 amount1, bytes calldata hookData)\n        internal\n        noSelfCall(self)\n    {\n        if (self.hasPermission(AFTER_DONATE_FLAG)) {\n            self.callHook(abi.encodeCall(IHooks.afterDonate, (msg.sender, key, amount0, amount1, hookData)));\n        }\n    }\n\n    function hasPermission(IHooks self, uint160 flag) internal pure returns (bool) {\n        return uint160(address(self)) & flag != 0;\n    }\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/libraries/LPFeeLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @notice Library of helper functions for a pools LP fee\nlibrary LPFeeLibrary {\n    using LPFeeLibrary for uint24;\n    using CustomRevert for bytes4;\n\n    /// @notice Thrown when the static or dynamic fee on a pool exceeds 100%.\n    error LPFeeTooLarge(uint24 fee);\n\n    /// @notice An lp fee of exactly 0b1000000... signals a dynamic fee pool. This isn't a valid static fee as it is > MAX_LP_FEE\n    uint24 public constant DYNAMIC_FEE_FLAG = 0x800000;\n\n    /// @notice the second bit of the fee returned by beforeSwap is used to signal if the stored LP fee should be overridden in this swap\n    // only dynamic-fee pools can return a fee via the beforeSwap hook\n    uint24 public constant OVERRIDE_FEE_FLAG = 0x400000;\n\n    /// @notice mask to remove the override fee flag from a fee returned by the beforeSwaphook\n    uint24 public constant REMOVE_OVERRIDE_MASK = 0xBFFFFF;\n\n    /// @notice the lp fee is represented in hundredths of a bip, so the max is 100%\n    uint24 public constant MAX_LP_FEE = 1000000;\n\n    /// @notice returns true if a pool's LP fee signals that the pool has a dynamic fee\n    /// @param self The fee to check\n    /// @return bool True of the fee is dynamic\n    function isDynamicFee(uint24 self) internal pure returns (bool) {\n        return self == DYNAMIC_FEE_FLAG;\n    }\n\n    /// @notice returns true if an LP fee is valid, aka not above the maximum permitted fee\n    /// @param self The fee to check\n    /// @return bool True of the fee is valid\n    function isValid(uint24 self) internal pure returns (bool) {\n        return self <= MAX_LP_FEE;\n    }\n\n    /// @notice validates whether an LP fee is larger than the maximum, and reverts if invalid\n    /// @param self The fee to validate\n    function validate(uint24 self) internal pure {\n        if (!self.isValid()) LPFeeTooLarge.selector.revertWith(self);\n    }\n\n    /// @notice gets and validates the initial LP fee for a pool. Dynamic fee pools have an initial fee of 0.\n    /// @dev if a dynamic fee pool wants a non-0 initial fee, it should call `updateDynamicLPFee` in the afterInitialize hook\n    /// @param self The fee to get the initial LP from\n    /// @return initialFee 0 if the fee is dynamic, otherwise the fee (if valid)\n    function getInitialLPFee(uint24 self) internal pure returns (uint24) {\n        // the initial fee for a dynamic fee pool is 0\n        if (self.isDynamicFee()) return 0;\n        self.validate();\n        return self;\n    }\n\n    /// @notice returns true if the fee has the override flag set (2nd highest bit of the uint24)\n    /// @param self The fee to check\n    /// @return bool True of the fee has the override flag set\n    function isOverride(uint24 self) internal pure returns (bool) {\n        return self & OVERRIDE_FEE_FLAG != 0;\n    }\n\n    /// @notice returns a fee with the override flag removed\n    /// @param self The fee to remove the override flag from\n    /// @return fee The fee without the override flag set\n    function removeOverrideFlag(uint24 self) internal pure returns (uint24) {\n        return self & REMOVE_OVERRIDE_MASK;\n    }\n\n    /// @notice Removes the override flag and validates the fee (reverts if the fee is too large)\n    /// @param self The fee to remove the override flag from, and then validate\n    /// @return fee The fee without the override flag set (if valid)\n    function removeOverrideFlagAndValidate(uint24 self) internal pure returns (uint24 fee) {\n        fee = self.removeOverrideFlag();\n        fee.validate();\n    }\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/libraries/ParseBytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @notice Parses bytes returned from hooks and the byte selector used to check return selectors from hooks.\n/// @dev parseSelector also is used to parse the expected selector\n/// For parsing hook returns, note that all hooks return either bytes4 or (bytes4, 32-byte-delta) or (bytes4, 32-byte-delta, uint24).\nlibrary ParseBytes {\n    function parseSelector(bytes memory result) internal pure returns (bytes4 selector) {\n        // equivalent: (selector,) = abi.decode(result, (bytes4, int256));\n        assembly (\"memory-safe\") {\n            selector := mload(add(result, 0x20))\n        }\n    }\n\n    function parseFee(bytes memory result) internal pure returns (uint24 lpFee) {\n        // equivalent: (,, lpFee) = abi.decode(result, (bytes4, int256, uint24));\n        assembly (\"memory-safe\") {\n            lpFee := mload(add(result, 0x60))\n        }\n    }\n\n    function parseReturnDelta(bytes memory result) internal pure returns (int256 hookReturn) {\n        // equivalent: (, hookReturnDelta) = abi.decode(result, (bytes4, int256));\n        assembly (\"memory-safe\") {\n            hookReturn := mload(add(result, 0x40))\n        }\n    }\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    using CustomRevert for bytes4;\n\n    error SafeCastOverflow();\n\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return y The downcasted integer, now type uint160\n    function toUint160(uint256 x) internal pure returns (uint160 y) {\n        y = uint160(x);\n        if (y != x) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a uint128, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return y The downcasted integer, now type uint128\n    function toUint128(uint256 x) internal pure returns (uint128 y) {\n        y = uint128(x);\n        if (x != y) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a int128 to a uint128, revert on overflow or underflow\n    /// @param x The int128 to be casted\n    /// @return y The casted integer, now type uint128\n    function toUint128(int128 x) internal pure returns (uint128 y) {\n        if (x < 0) SafeCastOverflow.selector.revertWith();\n        y = uint128(x);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param x The int256 to be downcasted\n    /// @return y The downcasted integer, now type int128\n    function toInt128(int256 x) internal pure returns (int128 y) {\n        y = int128(x);\n        if (y != x) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param x The uint256 to be casted\n    /// @return y The casted integer, now type int256\n    function toInt256(uint256 x) internal pure returns (int256 y) {\n        y = int256(x);\n        if (y < 0) SafeCastOverflow.selector.revertWith();\n    }\n\n    /// @notice Cast a uint256 to a int128, revert on overflow\n    /// @param x The uint256 to be downcasted\n    /// @return The downcasted integer, now type int128\n    function toInt128(uint256 x) internal pure returns (int128) {\n        if (x >= 1 << 127) SafeCastOverflow.selector.revertWith();\n        return int128(int256(x));\n    }\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/types/BalanceDelta.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeCast} from \"../libraries/SafeCast.sol\";\n\n/// @dev Two `int128` values packed into a single `int256` where the upper 128 bits represent the amount0\n/// and the lower 128 bits represent the amount1.\ntype BalanceDelta is int256;\n\nusing {add as +, sub as -, eq as ==, neq as !=} for BalanceDelta global;\nusing BalanceDeltaLibrary for BalanceDelta global;\nusing SafeCast for int256;\n\nfunction toBalanceDelta(int128 _amount0, int128 _amount1) pure returns (BalanceDelta balanceDelta) {\n    assembly (\"memory-safe\") {\n        balanceDelta := or(shl(128, _amount0), and(sub(shl(128, 1), 1), _amount1))\n    }\n}\n\nfunction add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    int256 res0;\n    int256 res1;\n    assembly (\"memory-safe\") {\n        let a0 := sar(128, a)\n        let a1 := signextend(15, a)\n        let b0 := sar(128, b)\n        let b1 := signextend(15, b)\n        res0 := add(a0, b0)\n        res1 := add(a1, b1)\n    }\n    return toBalanceDelta(res0.toInt128(), res1.toInt128());\n}\n\nfunction sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    int256 res0;\n    int256 res1;\n    assembly (\"memory-safe\") {\n        let a0 := sar(128, a)\n        let a1 := signextend(15, a)\n        let b0 := sar(128, b)\n        let b1 := signextend(15, b)\n        res0 := sub(a0, b0)\n        res1 := sub(a1, b1)\n    }\n    return toBalanceDelta(res0.toInt128(), res1.toInt128());\n}\n\nfunction eq(BalanceDelta a, BalanceDelta b) pure returns (bool) {\n    return BalanceDelta.unwrap(a) == BalanceDelta.unwrap(b);\n}\n\nfunction neq(BalanceDelta a, BalanceDelta b) pure returns (bool) {\n    return BalanceDelta.unwrap(a) != BalanceDelta.unwrap(b);\n}\n\n/// @notice Library for getting the amount0 and amount1 deltas from the BalanceDelta type\nlibrary BalanceDeltaLibrary {\n    /// @notice A BalanceDelta of 0\n    BalanceDelta public constant ZERO_DELTA = BalanceDelta.wrap(0);\n\n    function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0) {\n        assembly (\"memory-safe\") {\n            _amount0 := sar(128, balanceDelta)\n        }\n    }\n\n    function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1) {\n        assembly (\"memory-safe\") {\n            _amount1 := signextend(15, balanceDelta)\n        }\n    }\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/types/BeforeSwapDelta.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Return type of the beforeSwap hook.\n// Upper 128 bits is the delta in specified tokens. Lower 128 bits is delta in unspecified tokens (to match the afterSwap hook)\ntype BeforeSwapDelta is int256;\n\n// Creates a BeforeSwapDelta from specified and unspecified\nfunction toBeforeSwapDelta(int128 deltaSpecified, int128 deltaUnspecified)\n    pure\n    returns (BeforeSwapDelta beforeSwapDelta)\n{\n    assembly (\"memory-safe\") {\n        beforeSwapDelta := or(shl(128, deltaSpecified), and(sub(shl(128, 1), 1), deltaUnspecified))\n    }\n}\n\n/// @notice Library for getting the specified and unspecified deltas from the BeforeSwapDelta type\nlibrary BeforeSwapDeltaLibrary {\n    /// @notice A BeforeSwapDelta of 0\n    BeforeSwapDelta public constant ZERO_DELTA = BeforeSwapDelta.wrap(0);\n\n    /// extracts int128 from the upper 128 bits of the BeforeSwapDelta\n    /// returned by beforeSwap\n    function getSpecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaSpecified) {\n        assembly (\"memory-safe\") {\n            deltaSpecified := sar(128, delta)\n        }\n    }\n\n    /// extracts int128 from the lower 128 bits of the BeforeSwapDelta\n    /// returned by beforeSwap and afterSwap\n    function getUnspecifiedDelta(BeforeSwapDelta delta) internal pure returns (int128 deltaUnspecified) {\n        assembly (\"memory-safe\") {\n            deltaUnspecified := signextend(15, delta)\n        }\n    }\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/types/Currency.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20Minimal} from \"../interfaces/external/IERC20Minimal.sol\";\nimport {CustomRevert} from \"../libraries/CustomRevert.sol\";\n\ntype Currency is address;\n\nusing {greaterThan as >, lessThan as <, greaterThanOrEqualTo as >=, equals as ==} for Currency global;\nusing CurrencyLibrary for Currency global;\n\nfunction equals(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) == Currency.unwrap(other);\n}\n\nfunction greaterThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) > Currency.unwrap(other);\n}\n\nfunction lessThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) < Currency.unwrap(other);\n}\n\nfunction greaterThanOrEqualTo(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) >= Currency.unwrap(other);\n}\n\n/// @title CurrencyLibrary\n/// @dev This library allows for transferring and holding native tokens and ERC20 tokens\nlibrary CurrencyLibrary {\n    /// @notice Additional context for ERC-7751 wrapped error when a native transfer fails\n    error NativeTransferFailed();\n\n    /// @notice Additional context for ERC-7751 wrapped error when an ERC20 transfer fails\n    error ERC20TransferFailed();\n\n    /// @notice A constant to represent the native currency\n    Currency public constant ADDRESS_ZERO = Currency.wrap(address(0));\n\n    function transfer(Currency currency, address to, uint256 amount) internal {\n        // altered from https://github.com/transmissions11/solmate/blob/44a9963d4c78111f77caa0e65d677b8b46d6f2e6/src/utils/SafeTransferLib.sol\n        // modified custom error selectors\n\n        bool success;\n        if (currency.isAddressZero()) {\n            assembly (\"memory-safe\") {\n                // Transfer the ETH and revert if it fails.\n                success := call(gas(), to, amount, 0, 0, 0, 0)\n            }\n            // revert with NativeTransferFailed, containing the bubbled up error as an argument\n            if (!success) {\n                CustomRevert.bubbleUpAndRevertWith(to, bytes4(0), NativeTransferFailed.selector);\n            }\n        } else {\n            assembly (\"memory-safe\") {\n                // Get a pointer to some free memory.\n                let fmp := mload(0x40)\n\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\n                mstore(fmp, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n                mstore(add(fmp, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n                mstore(add(fmp, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n                success :=\n                    and(\n                        // Set success to whether the call reverted, if not we check it either\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                        // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                        // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                        // Counterintuitively, this call must be positioned second to the or() call in the\n                        // surrounding and() call or else returndatasize() will be zero during the computation.\n                        call(gas(), currency, 0, fmp, 68, 0, 32)\n                    )\n\n                // Now clean the memory we used\n                mstore(fmp, 0) // 4 byte `selector` and 28 bytes of `to` were stored here\n                mstore(add(fmp, 0x20), 0) // 4 bytes of `to` and 28 bytes of `amount` were stored here\n                mstore(add(fmp, 0x40), 0) // 4 bytes of `amount` were stored here\n            }\n            // revert with ERC20TransferFailed, containing the bubbled up error as an argument\n            if (!success) {\n                CustomRevert.bubbleUpAndRevertWith(\n                    Currency.unwrap(currency), IERC20Minimal.transfer.selector, ERC20TransferFailed.selector\n                );\n            }\n        }\n    }\n\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\n        if (currency.isAddressZero()) {\n            return address(this).balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(address(this));\n        }\n    }\n\n    function balanceOf(Currency currency, address owner) internal view returns (uint256) {\n        if (currency.isAddressZero()) {\n            return owner.balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(owner);\n        }\n    }\n\n    function isAddressZero(Currency currency) internal pure returns (bool) {\n        return Currency.unwrap(currency) == Currency.unwrap(ADDRESS_ZERO);\n    }\n\n    function toId(Currency currency) internal pure returns (uint256) {\n        return uint160(Currency.unwrap(currency));\n    }\n\n    // If the upper 12 bytes are non-zero, they will be zero-ed out\n    // Therefore, fromId() and toId() are not inverses of each other\n    function fromId(uint256 id) internal pure returns (Currency) {\n        return Currency.wrap(address(uint160(id)));\n    }\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/types/PoolId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {PoolKey} from \"./PoolKey.sol\";\n\ntype PoolId is bytes32;\n\n/// @notice Library for computing the ID of a pool\nlibrary PoolIdLibrary {\n    /// @notice Returns value equal to keccak256(abi.encode(poolKey))\n    function toId(PoolKey memory poolKey) internal pure returns (PoolId poolId) {\n        assembly (\"memory-safe\") {\n            // 0xa0 represents the total size of the poolKey struct (5 slots of 32 bytes)\n            poolId := keccak256(poolKey, 0xa0)\n        }\n    }\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/types/PoolKey.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Currency} from \"./Currency.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {PoolIdLibrary} from \"./PoolId.sol\";\n\nusing PoolIdLibrary for PoolKey global;\n\n/// @notice Returns the key for identifying a pool\nstruct PoolKey {\n    /// @notice The lower currency of the pool, sorted numerically\n    Currency currency0;\n    /// @notice The higher currency of the pool, sorted numerically\n    Currency currency1;\n    /// @notice The pool LP fee, capped at 1_000_000. If the highest bit is 1, the pool has a dynamic fee and must be exactly equal to 0x800000\n    uint24 fee;\n    /// @notice Ticks that involve positions must be a multiple of tick spacing\n    int24 tickSpacing;\n    /// @notice The hooks of the pool\n    IHooks hooks;\n}\n"
    },
    "uniswap-v4/lib/v4-core/src/types/PoolOperation.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\n\n/// @notice Parameter struct for `ModifyLiquidity` pool operations\nstruct ModifyLiquidityParams {\n    // the lower and upper tick of the position\n    int24 tickLower;\n    int24 tickUpper;\n    // how to modify the liquidity\n    int256 liquidityDelta;\n    // a value to set if you want unique liquidity positions at the same range\n    bytes32 salt;\n}\n\n/// @notice Parameter struct for `Swap` pool operations\nstruct SwapParams {\n    /// Whether to swap token0 for token1 or vice versa\n    bool zeroForOne;\n    /// The desired input amount if negative (exactIn), or the desired output amount if positive (exactOut)\n    int256 amountSpecified;\n    /// The sqrt price at which, if reached, the swap will stop executing\n    uint160 sqrtPriceLimitX96;\n}\n"
    },
    "uniswap-v4/src/base/ChainLinkConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\nimport {UnknownRequest, FunctionsError, AlreadyInitialized, IndexOutOfBounds, EmptyTop, ZeroValue} from \"./Errors.sol\";\n\nimport {FunctionsClient} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol\";\nimport {FunctionsRequest} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol\";\n\nimport {DaemonRegistry} from \"./DaemonRegistry.sol\";\n\ncontract ChainLinkConsumer is FunctionsClient {\n  using FunctionsRequest for FunctionsRequest.Request;\n\n  bytes32 public donId;\n  uint256[8] public topPacked; // packed 128 uint16 ids (16 ids per 256-bit word)\n  uint16 public topCount; // optional; may be <=128, 0 if unknown\n  uint16 public topCursor; // current index in top list\n  bytes32 public lastRequestId;\n  uint64 public topEpoch; // increments on each successful top update\n  uint256 public epochDurationBlocks; // 0 disables block-based expiration\n  uint256 public lastEpochStartBlock; // block when current epoch started\n  bool public hasPendingTopRequest; // prevents spamming requests\n\n  event TopRefreshRequested(uint64 epoch, uint256 atBlock);\n\n  event TopIdsUpdated(uint16 count);\n\n  constructor(address router, bytes32 _donId) FunctionsClient(router) {\n    donId = _donId;\n  }\n\n  function _sendRequestInternal(\n    string calldata source,\n    FunctionsRequest.Location secretsLocation,\n    bytes calldata encryptedSecretsReference,\n    string[] calldata args,\n    bytes[] calldata bytesArgs,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit\n  ) internal {\n    FunctionsRequest.Request memory req;\n    req.initializeRequest(FunctionsRequest.Location.Inline, FunctionsRequest.CodeLanguage.JavaScript, source);\n    req.secretsLocation = secretsLocation;\n    req.encryptedSecretsReference = encryptedSecretsReference;\n    if (args.length > 0) {\n      req.setArgs(args);\n    }\n    if (bytesArgs.length > 0) {\n      req.setBytesArgs(bytesArgs);\n    }\n    lastRequestId = _sendRequest(req.encodeCBOR(), subscriptionId, callbackGasLimit, donId);\n  }\n\n  // --- Admin methods (internal control) ---\n  function setEpochDurationBlocks(uint256 blocks_) internal {\n    if (blocks_ == 0) revert ZeroValue();\n    epochDurationBlocks = blocks_;\n  }\n\n  // removed external requestTopUpdate per design\n\n  function fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal override {\n    if (requestId != lastRequestId) revert UnknownRequest();\n    if (err.length != 0) revert FunctionsError();\n    uint256[8] memory words = abi.decode(response, (uint256[8]));\n    // Single SSTORE per word (8 total) to keep callback gas low\n    for (uint256 i = 0; i < 8; i++) {\n      topPacked[i] = words[i];\n    }\n    // Derive topCount from non-sentinel ids (0xFFFF) packed in words\n    uint16 count = 0;\n    for (uint256 i = 0; i < 128; i++) {\n      uint256 wordIndex = i / 16;\n      uint256 slot = i % 16;\n      uint256 word = words[wordIndex];\n      uint16 id = uint16((word >> (slot * 16)) & 0xffff);\n      if (id == 0xffff) {\n        break;\n      }\n      unchecked {\n        count++;\n      }\n    }\n    topCount = count;\n    topCursor = 0;\n    topEpoch++;\n    hasPendingTopRequest = false;\n    lastEpochStartBlock = block.number;\n    emit TopIdsUpdated(topCount);\n  }\n\n  /// If epoch expired and no request is pending, mark pending and emit event\n  function _maybeRequestTopUpdate() internal {\n    if (epochDurationBlocks == 0) {\n      return;\n    }\n    bool expired = block.number >= lastEpochStartBlock + epochDurationBlocks;\n    if (expired && !hasPendingTopRequest) {\n      hasPendingTopRequest = true;\n      emit TopRefreshRequested(topEpoch, block.number);\n    }\n  }\n\n  // Start rebate epochs with initial duration and send first request (hook exposes a wrapper)\n  function _startRebateEpochs(\n    uint256 initialEpochDurationBlocks,\n    string calldata source,\n    FunctionsRequest.Location secretsLocation,\n    bytes calldata encryptedSecretsReference,\n    string[] calldata args,\n    bytes[] calldata bytesArgs,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit\n  ) internal {\n    if (epochDurationBlocks != 0) revert AlreadyInitialized();\n    setEpochDurationBlocks(initialEpochDurationBlocks);\n    hasPendingTopRequest = true;\n    _sendRequestInternal(\n      source,\n      secretsLocation,\n      encryptedSecretsReference,\n      args,\n      bytesArgs,\n      subscriptionId,\n      callbackGasLimit\n    );\n  }\n\n  function topIdsAt(uint256 index) external view returns (uint16) {\n    if (index >= topCount) revert IndexOutOfBounds();\n    uint256 wordIndex = index / 16;\n    uint256 slot = index % 16;\n    uint256 word = topPacked[wordIndex];\n    return uint16((word >> (slot * 16)) & 0xffff);\n  }\n\n  function getCurrentTop() public view returns (address daemon) {\n    if (topCount == 0) revert EmptyTop();\n    uint256 wordIndex = uint256(topCursor) / 16;\n    uint256 slot = uint256(topCursor) % 16;\n    uint256 word = topPacked[wordIndex];\n    uint16 id = uint16((word >> (slot * 16)) & 0xffff);\n    daemon = DaemonRegistry(address(this)).getById(id);\n  }\n\n  function iterNextTop() internal {\n    if (topCount == 0) revert EmptyTop();\n    unchecked {\n      uint16 next = topCursor + 1;\n      if (next >= topCount) {\n        next = 0;\n      }\n      topCursor = next;\n    }\n  }\n}\n"
    },
    "uniswap-v4/src/base/DaemonRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\nimport {IDaemon} from \"../interfaces/IDaemon.sol\";\nimport {ZeroAddress, DuplicateDaemon, CapacityExceeded, IdDoesNotExist, NotExist, DaemonIsBanned, NotDaemonOwner, CountInvalid, StartInvalid} from \"./Errors.sol\";\n\ncontract DaemonRegistry {\n  event Added(address indexed target, uint16 id);\n  event ActivationChanged(address indexed target, uint16 id, bool active);\n  event DaemonBanned(address indexed target, uint16 id);\n\n  // List of daemon contract addresses, index also serves as id (uint16)\n  address[] private _daemonAddresses;\n  mapping(address => bool) public exists;\n  mapping(address => uint16) public addressToId;\n  mapping(uint16 => address) public idToAddress;\n  mapping(address => bool) public active;\n  mapping(address => address) public daemonOwner; // daemon address => owner address\n  mapping(address => bool) public banned; // banned daemon cannot be activated\n\n  // Compact activation bitmap: bit i corresponds to id i\n  // Stored as 256-bit words for efficient updates\n  mapping(uint256 => uint256) private _activationBitmaskWords;\n  uint256 public bitWordCount; // number of 256-bit words used to cover current ids\n\n  function _ensureBitCapacity(uint256 numberOfIds) internal {\n    uint256 needed = (numberOfIds + 255) / 256;\n    if (needed > bitWordCount) {\n      bitWordCount = needed;\n    }\n  }\n\n  function _setActiveBit(uint16 daemonId, bool isActive) internal {\n    uint256 wordIndex = uint256(daemonId) / 256;\n    uint256 bitIndex = uint256(daemonId) % 256;\n    uint256 bitMask = (uint256(1) << bitIndex);\n    uint256 currentWord = _activationBitmaskWords[wordIndex];\n    if (isActive) {\n      currentWord |= bitMask;\n    } else {\n      currentWord &= ~bitMask;\n    }\n    _activationBitmaskWords[wordIndex] = currentWord;\n  }\n\n  // Note: bulk add is handled in the hook to also capture per-daemon owners\n\n  // TODO: ADD OnlyHookOwner\n  function _add(address daemon, address owner) internal {\n    if (daemon == address(0)) revert ZeroAddress();\n    if (exists[daemon]) revert DuplicateDaemon();\n    if (_daemonAddresses.length >= 3200) revert CapacityExceeded();\n    uint16 daemonId = uint16(_daemonAddresses.length);\n    exists[daemon] = true;\n    addressToId[daemon] = daemonId;\n    idToAddress[daemonId] = daemon;\n    _daemonAddresses.push(daemon);\n    daemonOwner[daemon] = owner;\n    emit Added(daemon, daemonId);\n    // active[daemon] is false by default\n    _ensureBitCapacity(_daemonAddresses.length);\n  }\n\n  function length() external view returns (uint256) {\n    return _daemonAddresses.length;\n  }\n\n  function getAt(uint256 index) external view returns (address) {\n    return _daemonAddresses[index];\n  }\n\n  function getAll() external view returns (address[] memory) {\n    return _daemonAddresses;\n  }\n\n  function getById(uint16 daemonId) external view returns (address) {\n    address daemon = idToAddress[daemonId];\n    if (daemon == address(0)) revert IdDoesNotExist();\n    return daemon;\n  }\n\n  /// Packed addresses: 20*N bytes\n  function packedAll() external view returns (bytes memory) {\n    return abi.encodePacked(_daemonAddresses);\n  }\n\n  function packedHash() external view returns (bytes32) {\n    return keccak256(abi.encodePacked(_daemonAddresses));\n  }\n\n  function _setActive(address daemon, bool isActive) internal {\n    if (!exists[daemon]) revert NotExist();\n    if (isActive) {\n      if (banned[daemon]) revert DaemonIsBanned();\n    }\n    uint16 daemonId = addressToId[daemon];\n    active[daemon] = isActive;\n    _setActiveBit(daemonId, isActive);\n    emit ActivationChanged(daemon, daemonId, isActive);\n  }\n\n  function _setActiveById(uint16 daemonId, bool isActive) internal {\n    address daemon = idToAddress[daemonId];\n    if (daemon == address(0)) revert NotExist();\n    if (isActive) {\n      if (banned[daemon]) revert DaemonIsBanned();\n    }\n    active[daemon] = isActive;\n    _setActiveBit(daemonId, isActive);\n    emit ActivationChanged(daemon, daemonId, isActive);\n  }\n\n  // Internal ban API for hook admin: disables daemon and prevents later activation by owner\n  function _banDaemon(address daemon) internal {\n    if (!exists[daemon]) revert NotExist();\n    uint16 daemonId = addressToId[daemon];\n    banned[daemon] = true;\n    if (active[daemon]) {\n      active[daemon] = false;\n      _setActiveBit(daemonId, false);\n      emit ActivationChanged(daemon, daemonId, false);\n    }\n    emit DaemonBanned(daemon, daemonId);\n  }\n\n  // Single-activation APIs restricted to daemon owner\n  function setActive(address daemon, bool isActive) external {\n    if (!exists[daemon]) revert NotExist();\n    if (msg.sender != daemonOwner[daemon]) revert NotDaemonOwner();\n    _setActive(daemon, isActive);\n  }\n\n  function setActiveById(uint16 daemonId, bool isActive) external {\n    address daemon = idToAddress[daemonId];\n    if (daemon == address(0)) revert NotExist();\n    if (msg.sender != daemonOwner[daemon]) revert NotDaemonOwner();\n    _setActive(daemon, isActive);\n  }\n\n  // TODO: ADD OnlyHookOwner\n  function _activateMany(address[] calldata daemonAddresses) internal {\n    for (uint256 index = 0; index < daemonAddresses.length; index++) {\n      address daemon = daemonAddresses[index];\n      if (exists[daemon] && !active[daemon]) {\n        active[daemon] = true;\n        _setActiveBit(addressToId[daemon], true);\n        emit ActivationChanged(daemon, addressToId[daemon], true);\n      }\n    }\n  }\n\n  // TODO: ADD OnlyHookOwner\n  function _deactivateMany(address[] calldata daemonAddresses) internal {\n    for (uint256 index = 0; index < daemonAddresses.length; index++) {\n      address daemon = daemonAddresses[index];\n      if (exists[daemon] && active[daemon]) {\n        active[daemon] = false;\n        _setActiveBit(addressToId[daemon], false);\n        emit ActivationChanged(daemon, addressToId[daemon], false);\n      }\n    }\n  }\n\n  /// Packed pairs: [id(1) | address(20)] * N\n  function packedPairs() external view returns (bytes memory out) {\n    uint256 total = _daemonAddresses.length;\n    out = new bytes(total * 21);\n    for (uint256 index = 0; index < total; index++) {\n      uint8 daemonId = uint8(addressToId[_daemonAddresses[index]]);\n      uint256 base = 32 + index * 21;\n      assembly {\n        let p := add(out, base)\n        mstore8(p, daemonId)\n      }\n      bytes20 daemonBytes = bytes20(_daemonAddresses[index]);\n      for (uint256 j = 0; j < 20; j++) {\n        bytes1 b = daemonBytes[j];\n        assembly {\n          mstore8(add(add(out, base), add(1, j)), byte(0, b))\n        }\n      }\n    }\n  }\n\n  function packedPairsHash() external view returns (bytes32) {\n    return keccak256(this.packedPairs());\n  }\n\n  /// Returns compact activation bitmap. Bit i corresponds to id i.\n  /// Length of the returned bytes is ceil(length()/8).\n  function activationBitmap() external view returns (bytes memory out) {\n    uint256 total = _daemonAddresses.length;\n    uint256 byteLen = (total + 7) / 8;\n    out = new bytes(byteLen);\n    for (uint256 index = 0; index < total; index++) {\n      if (active[_daemonAddresses[index]]) {\n        uint256 byteIndex = index / 8;\n        uint256 bitIndex = index % 8;\n        uint8 cur = uint8(out[byteIndex]);\n        uint8 mask = uint8(1) << uint8(bitIndex);\n        out[byteIndex] = bytes1(cur | mask);\n      }\n    }\n  }\n\n  function activationMeta() external view returns (uint256 total, bytes memory bitmap) {\n    total = _daemonAddresses.length;\n    bitmap = this.activationBitmap();\n  }\n\n  function aggregatePointsRange(\n    uint256 start,\n    uint256 count,\n    uint256 blockNumber\n  ) external view returns (int128[] memory points) {\n    if (!(count > 0 && count <= 800)) revert CountInvalid();\n    uint256 total = _daemonAddresses.length;\n    if (start > total) revert StartInvalid();\n    uint256 available = total > start ? total - start : 0;\n    uint256 toTake = count < available ? count : available;\n    points = new int128[](toTake);\n    if (toTake == 0) {\n      return points;\n    }\n    for (uint256 index = 0; index < toTake; index++) {\n      address daemon = _daemonAddresses[start + index];\n      if (!active[daemon]) {\n        points[index] = 0;\n        continue;\n      }\n      try IDaemon(daemon).getRebateAmount(blockNumber) returns (int128 value) {\n        points[index] = value;\n      } catch {\n        points[index] = 0;\n      }\n    }\n  }\n\n  /// Overload for Chainlink Functions script compatibility: uses current block number and returns uint128[]\n  function aggregatePointsRange(uint256 start, uint256 count) external view returns (uint128[] memory points) {\n    int128[] memory signedPoints = this.aggregatePointsRange(start, count, block.number);\n    points = new uint128[](signedPoints.length);\n    for (uint256 i = 0; i < signedPoints.length; i++) {\n      int128 value = signedPoints[i];\n      points[i] = value > 0 ? uint128(uint256(int256(value))) : uint128(0);\n    }\n  }\n\n  /// Aggregate getRebateAmount() for all addresses in id order\n  function aggregatePointsAll(uint256 blockNumber) external view returns (int128[] memory points) {\n    uint256 total = _daemonAddresses.length;\n    points = new int128[](total);\n    for (uint256 index = 0; index < total; index++) {\n      address daemon = _daemonAddresses[index];\n      try IDaemon(daemon).getRebateAmount(blockNumber) returns (int128 value) {\n        points[index] = value;\n      } catch {\n        points[index] = 0;\n      }\n    }\n  }\n\n  /// Aggregate getRebateAmount() for all addresses in id order, returning 0 for inactive\n  function aggregatePointsMasked(uint256 blockNumber) external view returns (int128[] memory points) {\n    uint256 total = _daemonAddresses.length;\n    points = new int128[](total);\n    for (uint256 index = 0; index < total; index++) {\n      address daemon = _daemonAddresses[index];\n      if (active[daemon]) {\n        try IDaemon(daemon).getRebateAmount(blockNumber) returns (int128 value) {\n          points[index] = value;\n        } catch {\n          points[index] = 0;\n        }\n      } else {\n        points[index] = 0;\n      }\n    }\n  }\n}\n"
    },
    "uniswap-v4/src/base/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nerror NotHookOwner();\nerror ZeroAddress();\nerror ZeroValue();\nerror UnknownRequest();\nerror FunctionsError();\nerror AlreadyInitialized();\nerror IndexOutOfBounds();\nerror EmptyTop();\nerror LengthMismatch();\n\nerror DuplicateDaemon();\nerror CapacityExceeded();\nerror IdDoesNotExist();\nerror NotExist();\nerror DaemonIsBanned();\nerror NotDaemonOwner();\nerror CountInvalid();\nerror StartInvalid();\n\nerror NotOwner();\nerror NotAuthorized();"
    },
    "uniswap-v4/src/base/HookOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\nimport {NotHookOwner, ZeroAddress} from \"./Errors.sol\";\n\n/// @notice Abstract contract for hook-level ownership management\nabstract contract HookOwnable {\n  address public hookOwner;\n\n  event HookOwnerTransferred(address indexed previousOwner, address indexed newOwner);\n  event HookOwnerRenounced(address indexed previousOwner);\n\n  /// @dev Internal setter for initial owner (used in constructor)\n  function _setHookOwner(address owner) internal {\n    hookOwner = owner;\n    emit HookOwnerTransferred(address(0), owner);\n  }\n\n  /// @notice Reverts if caller is not the hook owner\n  modifier onlyHookOwner() {\n    if (msg.sender != hookOwner) revert NotHookOwner();\n    _;\n  }\n\n  /// @notice Transfer hook ownership to a new address\n  function transferHookOwnership(address newOwner) external onlyHookOwner {\n    if (newOwner == address(0)) revert ZeroAddress();\n    address prev = hookOwner;\n    hookOwner = newOwner;\n    emit HookOwnerTransferred(prev, newOwner);\n  }\n\n  /// @notice Renounce ownership of the hook\n  function renounceHookOwnership() external onlyHookOwner {\n    address prev = hookOwner;\n    hookOwner = address(0);\n    emit HookOwnerRenounced(prev);\n  }\n}\n"
    },
    "uniswap-v4/src/base/PoolOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {PoolKey} from \"../../lib/v4-core/src/types/PoolKey.sol\";\nimport {PoolId, PoolIdLibrary} from \"../../lib/v4-core/src/types/PoolId.sol\";\n\n/// @notice Abstract contract for per-pool ownership management\nabstract contract PoolOwnable {\n  using PoolIdLibrary for PoolKey;\n  mapping(PoolId => address) private _owners;\n\n  event PoolOwnerTransferred(PoolId indexed poolId, address indexed previousOwner, address indexed newOwner);\n  event PoolOwnerRenounced(PoolId indexed poolId, address indexed previousOwner);\n\n  /// @dev Internal setter for initial owner (used in afterInitialize)\n  function _setPoolOwner(PoolKey calldata key, address owner) internal {\n    PoolId id = key.toId();\n    _owners[id] = owner;\n    emit PoolOwnerTransferred(id, address(0), owner);\n  }\n\n  /// @notice Returns the owner for a given pool\n  function poolOwner(PoolKey calldata key) public view returns (address) {\n    return _owners[key.toId()];\n  }\n\n  /// @notice Reverts if caller is not the owner of the pool\n  modifier onlyPoolOwner(PoolKey calldata key) {\n    require(msg.sender == poolOwner(key), \"PoolOwnable: caller is not the pool owner\");\n    _;\n  }\n\n  /// @notice Transfer pool ownership to a new address\n  function transferPoolOwnership(PoolKey calldata key, address newOwner) external onlyPoolOwner(key) {\n    require(newOwner != address(0), \"PoolOwnable: new owner is zero address\");\n    PoolId id = key.toId();\n    address prev = _owners[id];\n    _owners[id] = newOwner;\n    emit PoolOwnerTransferred(id, prev, newOwner);\n  }\n\n  /// @notice Renounce ownership of the pool\n  function renouncePoolOwnership(PoolKey calldata key) external onlyPoolOwner(key) {\n    PoolId id = key.toId();\n    address prev = _owners[id];\n    _owners[id] = address(0);\n    emit PoolOwnerRenounced(id, prev);\n  }\n}\n"
    },
    "uniswap-v4/src/Conflux.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {BaseHook} from \"../lib/uniswap-hooks/src/base/BaseHook.sol\";\nimport {Hooks} from \"../lib/v4-core/src/libraries/Hooks.sol\";\nimport {IPoolManager, SwapParams, ModifyLiquidityParams} from \"../lib/v4-core/src/interfaces/IPoolManager.sol\";\nimport {PoolKey} from \"../lib/v4-core/src/types/PoolKey.sol\";\nimport {PoolId, PoolIdLibrary} from \"../lib/v4-core/src/types/PoolId.sol\";\nimport {BalanceDelta} from \"../lib/v4-core/src/types/BalanceDelta.sol\";\nimport {Currency} from \"../lib/v4-core/src/types/Currency.sol\";\nimport {BeforeSwapDelta, BeforeSwapDeltaLibrary, toBeforeSwapDelta} from \"../lib/v4-core/src/types/BeforeSwapDelta.sol\";\nimport {FunctionsRequest} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {DaemonRegistry} from \"./base/DaemonRegistry.sol\";\nimport {HookOwnable} from \"./base/HookOwnable.sol\";\nimport {PoolOwnable} from \"./base/PoolOwnable.sol\";\nimport {ChainLinkConsumer} from \"./base/ChainLinkConsumer.sol\";\nimport {IDaemon} from \"./interfaces/IDaemon.sol\";\nimport {LengthMismatch} from \"./base/Errors.sol\";\n\ncontract Conflux is BaseHook, DaemonRegistry, ChainLinkConsumer, HookOwnable, PoolOwnable {\n  using PoolIdLibrary for PoolKey;\n\n  // NOTE: ---------------------------------------------------------\n  // state variables should typically be unique to a pool\n  // a single hook contract should be able to service multiple pools\n  // ---------------------------------------------------------------\n\n  event RebateDisabled(uint16 indexed daemonId, string reason);\n  event RebateExecuted(uint16 indexed daemonId, uint128 amount);\n  event DaemonJobSuccess(uint16 indexed daemonId);\n  event DaemonJobFailure(uint16 indexed daemonId, string reason);\n\n  mapping(PoolId => uint256 count) public beforeSwapCount;\n  mapping(PoolId => uint256 count) public afterSwapCount;\n\n  mapping(PoolId => uint256 count) public beforeAddLiquidityCount;\n  mapping(PoolId => uint256 count) public beforeRemoveLiquidityCount;\n\n  // Per-pool rebate control\n  mapping(PoolId => bool) public isRebateEnabled;\n  mapping(uint16 => uint256 blockNumber) public lastTimeRebateCommitted; // daemon id -> block number\n\n  address public immutable rebateToken; // Address of using stablecoin in current hook\n\n  // Exhaustion control over a single top epoch\n  uint64 private lastTopEpochSeen;\n  uint16 private processedInTopEpoch;\n\n  constructor(\n    IPoolManager _poolManager,\n    address router,\n    bytes32 _donId,\n    address _rebateToken\n  ) BaseHook(_poolManager) ChainLinkConsumer(router, _donId) {\n    rebateToken = _rebateToken;\n    _setHookOwner(msg.sender);\n  }\n\n  function getHookPermissions() public pure override returns (Hooks.Permissions memory) {\n    return\n      Hooks.Permissions({\n        beforeInitialize: false,\n        afterInitialize: true,\n        beforeAddLiquidity: true,\n        afterAddLiquidity: false,\n        beforeRemoveLiquidity: true,\n        afterRemoveLiquidity: false,\n        beforeSwap: true,\n        afterSwap: true,\n        beforeDonate: false,\n        afterDonate: false,\n        beforeSwapReturnDelta: false,\n        afterSwapReturnDelta: false,\n        afterAddLiquidityReturnDelta: false,\n        afterRemoveLiquidityReturnDelta: false\n      });\n  }\n\n  // -----------------------------------------------\n  // NOTE: see IHooks.sol for function documentation\n  // -----------------------------------------------\n\n  function _afterInitialize(address sender, PoolKey calldata key, uint160, int24) internal override returns (bytes4) {\n    _setPoolOwner(key, sender);\n    // Enable rebate for this pool by default on initialization\n    isRebateEnabled[key.toId()] = true;\n    return BaseHook.afterInitialize.selector;\n  }\n\n  function _beforeSwap(\n    address,\n    PoolKey calldata key,\n    SwapParams calldata params,\n    bytes calldata\n  ) internal override returns (bytes4, BeforeSwapDelta, uint24) {\n    //\n    // Should return DAEMON ADDRESS with TOP REBATE AMOUNT within current ERA\n    // If epochs disabled (duration == 0), do not rebate\n    if (epochDurationBlocks == 0) {\n      return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n    }\n\n    // Block-based epoch expiration: if expired, request refresh but continue using current top\n    _maybeRequestTopUpdate();\n\n    // Reset per-epoch counter on new top epoch\n    if (topEpoch != lastTopEpochSeen) {\n      lastTopEpochSeen = topEpoch;\n      processedInTopEpoch = 0;\n    }\n\n    if (topCount == 0 || processedInTopEpoch >= topCount) {\n      return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n    }\n    address rebate_payer = getCurrentTop();\n    int128 daemonRebateAmount;\n\n    // Add fetch_current top. If rebate was successful -> iter to next top id\n\n    // ------------------------------------------------------\n\n    PoolId id = key.toId();\n\n    // Ensure pool contains the rebate token; otherwise do nothing gracefully\n    address token0 = Currency.unwrap(key.currency0);\n    address token1 = Currency.unwrap(key.currency1);\n    if (!(token0 == rebateToken || token1 == rebateToken)) {\n      return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n    }\n    bool isRebateToken0 = (token0 == rebateToken);\n\n    // 1-st check that current pool allows rebate\n    if (!isRebateEnabled[id]) {\n      return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n    }\n\n    // 2-nd check that current daemon has valid rebate amount\n    try IDaemon(rebate_payer).getRebateAmount(block.number) returns (int128 amount) {\n      if (amount <= 0) {\n        processedInTopEpoch++;\n        iterNextTop();\n        return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n      }\n      daemonRebateAmount = amount;\n    } catch {\n      _setActive(rebate_payer, false);\n      emit RebateDisabled(addressToId[rebate_payer], \"Failed to fetch rebate amount\");\n      processedInTopEpoch++;\n      iterNextTop();\n      return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n    }\n\n    // Now we don't need a separate delay options, because we define the needed delay as\n    // rebateAmount = 0 (would be sorted at JS Chainlink Functions side)\n\n    // Sync PoolManager's balance and check before transfer\n    poolManager.sync(Currency.wrap(rebateToken));\n    uint256 balanceBefore = IERC20(rebateToken).balanceOf(address(poolManager));\n    uint256 requiredAmount = uint256(uint128(daemonRebateAmount));\n\n    // Pull tokens into PoolManager with error handling (supports non-standard ERC20s)\n    bool transferred = _tryTransferFrom(rebateToken, rebate_payer, address(poolManager), requiredAmount);\n    if (!transferred) {\n      _setActive(rebate_payer, false);\n      emit RebateDisabled(addressToId[rebate_payer], \"Transfer failed\");\n      processedInTopEpoch++;\n      iterNextTop();\n      return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n    }\n\n    // Check actual received (fee-on-transfer guard)\n    uint256 actualReceived = IERC20(rebateToken).balanceOf(address(poolManager)) - balanceBefore;\n    if (actualReceived < requiredAmount) {\n      _setActive(rebate_payer, false);\n      emit RebateDisabled(addressToId[rebate_payer], \"Insufficient rebate amount given\");\n      processedInTopEpoch++;\n      iterNextTop();\n      return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n    }\n\n    // Settle with PoolManager and update state\n    poolManager.settle();\n    lastTimeRebateCommitted[addressToId[rebate_payer]] = block.number;\n    emit RebateExecuted(addressToId[rebate_payer], uint128(actualReceived));\n\n    // Execute daemon job with 300k gas stipend; rebate is paid regardless of outcome\n    try IDaemon(rebate_payer).accomplishDaemonJob{gas: 300_000}() {\n      emit DaemonJobSuccess(addressToId[rebate_payer]);\n    } catch Error(string memory reason) {\n      emit DaemonJobFailure(addressToId[rebate_payer], reason);\n    } catch {\n      emit DaemonJobFailure(addressToId[rebate_payer], \"unknown error\");\n    }\n\n    // Calculate deltas based on swap direction\n    // Always rebate in rebateToken regardless of swap direction\n    bool rebateOnSpecified = (params.zeroForOne && isRebateToken0) || (!params.zeroForOne && !isRebateToken0);\n    int128 specDelta = rebateOnSpecified ? -daemonRebateAmount : int128(0);\n    int128 unspecDelta = rebateOnSpecified ? int128(0) : -daemonRebateAmount;\n\n    processedInTopEpoch++;\n    iterNextTop();\n    return (BaseHook.beforeSwap.selector, toBeforeSwapDelta(specDelta, unspecDelta), 0);\n  }\n\n  function _afterSwap(\n    address,\n    PoolKey calldata key,\n    SwapParams calldata,\n    BalanceDelta,\n    bytes calldata\n  ) internal override returns (bytes4, int128) {\n    afterSwapCount[key.toId()]++;\n    return (BaseHook.afterSwap.selector, 0);\n  }\n\n  function _beforeAddLiquidity(\n    address,\n    PoolKey calldata key,\n    ModifyLiquidityParams calldata,\n    bytes calldata\n  ) internal override returns (bytes4) {\n    beforeAddLiquidityCount[key.toId()]++;\n    return BaseHook.beforeAddLiquidity.selector;\n  }\n\n  function _beforeRemoveLiquidity(\n    address,\n    PoolKey calldata key,\n    ModifyLiquidityParams calldata,\n    bytes calldata\n  ) internal override returns (bytes4) {\n    beforeRemoveLiquidityCount[key.toId()]++;\n    return BaseHook.beforeRemoveLiquidity.selector;\n  }\n\n  // ---- Internal helpers ----\n  function _tryTransferFrom(address token, address from, address to, uint256 amount) internal returns (bool) {\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\n    );\n    if (!success) return false;\n    if (data.length == 0) return true; // non-standard ERC20\n    if (data.length == 32) return abi.decode(data, (bool));\n    return false;\n  }\n\n  // ---- Admin APIs (hook owner) and user-facing single-activation ----\n  // Initialize consumer via hook owner\n  function startRebateEpochs(\n    uint256 initialEpochDurationBlocks,\n    string calldata source,\n    FunctionsRequest.Location secretsLocation,\n    bytes calldata encryptedSecretsReference,\n    string[] calldata args,\n    bytes[] calldata bytesArgs,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit\n  ) external onlyHookOwner {\n    _startRebateEpochs(\n      initialEpochDurationBlocks,\n      source,\n      secretsLocation,\n      encryptedSecretsReference,\n      args,\n      bytesArgs,\n      subscriptionId,\n      callbackGasLimit\n    );\n  }\n\n  // Set epoch length (in blocks) with hook-owner restriction\n  function setEpochLength(uint256 blocks_) external onlyHookOwner {\n    setEpochDurationBlocks(blocks_);\n  }\n\n  // Add many daemons with their owners (admin only)\n  function addMany(address[] calldata daemonAddresses, address[] calldata owners) external onlyHookOwner {\n    if (daemonAddresses.length != owners.length) revert LengthMismatch();\n    for (uint256 i = 0; i < daemonAddresses.length; i++) {\n      _add(daemonAddresses[i], owners[i]);\n    }\n  }\n\n  // Add single daemon with its owner (admin only)\n  function add(address daemon, address owner) external onlyHookOwner {\n    _add(daemon, owner);\n  }\n\n  // Bulk activate/deactivate by admin owner\n  function activateMany(address[] calldata daemonAddresses) external onlyHookOwner {\n    _activateMany(daemonAddresses);\n  }\n\n  function deactivateMany(address[] calldata daemonAddresses) external onlyHookOwner {\n    _deactivateMany(daemonAddresses);\n  }\n\n  // Ban daemon (admin only): disables and prevents future activation by owner\n  function banDaemon(address daemon) external onlyHookOwner {\n    _banDaemon(daemon);\n  }\n\n  // Note: single activation functions are inherited:\n  // - setActive(address daemon, bool isActive) -> only daemon owner\n  // - setActiveById(uint16 daemonId, bool isActive) -> only daemon owner\n\n  // ---- Per-pool rebate admin ----\n  function toggleRebate(PoolKey calldata key) external onlyPoolOwner(key) {\n    PoolId id = key.toId();\n    bool newState = !isRebateEnabled[id];\n    isRebateEnabled[id] = newState;\n  }\n\n  function getRebateState(PoolKey calldata key) external view returns (bool) {\n    return isRebateEnabled[key.toId()];\n  }\n}\n"
    },
    "uniswap-v4/src/interfaces/IDaemon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\ninterface IDaemon {\n  function getRebateAmount(uint256 blockNumber) external view returns (int128);\n  function accomplishDaemonJob() external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}
